=== iOS Swift Implementation ===
/**
 * TrustArc Consent Implementation for iOS
 *
 * This file provides a simplified interface for integrating the TrustArc Mobile Consent SDK
 * into your iOS application. It handles SDK initialization, consent management,
 * and delegate callbacks.
 *
 * Quick Start:
 * 1. Initialize when app starts: TrustArcConsentImpl.shared.initialize()
 * 2. Show consent dialog: TrustArcConsentImpl.shared.openCm()
 * 3. Get consent status: TrustArc.sharedInstance.getConsentDataByCategory()
 *
 * @author TrustArc Mobile Team
 * @version 1.0.0
 */

import Foundation
import SwiftUI
import WebKit
import trustarc_consent_sdk

// MARK: - TrustArc Consent Manager

/**
 * TrustArc Consent Manager Implementation
 *
 * Provides a streamlined interface for TrustArc consent management operations
 * including SDK initialization, consent dialog presentation, and delegate handling.
 *
 * This class manages the TrustArc SDK lifecycle and provides convenient
 * methods for consent operations throughout your application.
 */
@MainActor
class TrustArcConsentImpl: ObservableObject {

    // ===== SINGLETON =====
    static let shared = TrustArcConsentImpl()
    private init() {}

    // ===== STATE TRACKING =====
    /// SDK initialization status
    @Published var isReady = false

    // ===== CONFIGURATION =====
    /// TrustArc domain name for consent management
    /// This will be replaced during CLI installation with your specific domain
    private let domain = "__TRUSTARC_DOMAIN_PLACEHOLDER__"

    /// SDK mode: .standard for regular operation, .iabTCFv_2_2 for TCF compliance
    private let sdkMode: SdkMode = .standard

    /// Enable App Tracking Transparency prompt
    private let enableATT = true

    /// Enable debug logging for development and troubleshooting
    private let enableDebugLogs = true

    // ===== EVENT CALLBACKS =====
    /// Callback function for consent changes
    private var onConsentChangedCallback: (([String: TAConsent]) -> Void)?

    /// Callback function for SDK initialization completion
    private var onSdkInitFinishCallback: (() -> Void)?

    // ===== INITIALIZATION METHODS =====

    /**
     * Initialize the TrustArc SDK
     *
     * This is the main entry point for integrating TrustArc consent management.
     * Call this method once when your app starts, typically in your SwiftUI App
     * struct or in your AppDelegate.
     *
     * Example usage in SwiftUI App:
     * ```swift
     * @main
     * struct MyApp: App {
     *     init() {
     *         TrustArcConsentImpl.shared.initialize()
     *     }
     *
     *     var body: some Scene {
     *         WindowGroup {
     *             ContentView()
     *         }
     *     }
     * }
     * ```
     *
     * Example usage in a View:
     * ```swift
     * struct ContentView: View {
     *     var body: some View {
     *         Text("Hello World")
     *             .onAppear {
     *                 TrustArcConsentImpl.shared.initialize()
     *             }
     *     }
     * }
     * ```
     *
     * Example usage with UIKit AppDelegate:
     * ```swift
     * func application(_ application: UIApplication,
     *                  didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
     *     Task { @MainActor in
     *         TrustArcConsentImpl.shared.initialize()
     *     }
     *     return true
     * }
     * ```
     */
    func initialize() {
        Task { @MainActor in
            // Do not run init when already initialized
            guard !TrustArc.sharedInstance.isInitialized else {
                if enableDebugLogs {
                    print("[TrustArc] Already initialized, skipping")
                }
                return
            }

            if enableDebugLogs {
                print("[TrustArc] Initializing SDK with domain: \(domain)")
            }

            // Register delegates to handle SDK callbacks
            _ = TrustArc.sharedInstance.addSdkInitializationDelegate(self)
            _ = TrustArc.sharedInstance.addConsentViewControllerDelegate(self)
            _ = TrustArc.sharedInstance.addReportingDelegate(self)

            // Configure TrustArc SDK settings
            _ = TrustArc.sharedInstance.setDomain(domain)
            _ = TrustArc.sharedInstance.setMode(sdkMode)
            _ = TrustArc.sharedInstance.enableAppTrackingTransparencyPrompt(enableATT)
            _ = TrustArc.sharedInstance.enableDebugLogs(enableDebugLogs)

            // Start the SDK with completion callback
            TrustArc.sharedInstance.start { shouldShowConsentUI in
                Task { @MainActor in
                    self.isReady = true

                    if self.enableDebugLogs {
                        print("[TrustArc] SDK initialization completed")
                    }

                    // Notify callback
                    self.onSdkInitFinishCallback?()

                    // Auto-show consent dialog if required
                    if shouldShowConsentUI {
                        self.openCm()
                    }
                }
            }
        }
    }

    // ===== CONSENT MANAGEMENT METHODS =====

    /**
     * Open the TrustArc consent management dialog
     *
     * Presents the consent preferences UI to the user, allowing them to
     * review and modify their consent choices.
     *
     * Example usage in SwiftUI:
     * ```swift
     * Button("Manage Privacy") {
     *     TrustArcConsentImpl.shared.openCm()
     * }
     * ```
     *
     * Example usage in UIKit:
     * ```swift
     * @IBAction func managePrivacyTapped(_ sender: UIButton) {
     *     Task { @MainActor in
     *         TrustArcConsentImpl.shared.openCm()
     *     }
     * }
     * ```
     *
     * The SDK must be initialized before calling this method.
     * The method requires a valid root view controller to present the dialog.
     */
    @MainActor
    func openCm() {
        guard let rootView = getRootViewController() else {
            if enableDebugLogs {
                print("[TrustArc] Cannot open CM - no root view controller")
            }
            return
        }

        if enableDebugLogs {
            print("[TrustArc] Opening consent management dialog")
        }

        TrustArc.sharedInstance.openCM(in: rootView, delegate: self)
    }

    /**
     * Get current consent data organized by category
     *
     * Retrieves the user's current consent preferences organized by category.
     * Returns a dictionary where keys are category names and values contain consent details.
     *
     * Example usage:
     * ```swift
     * let consents = TrustArcConsentImpl.shared.getConsentData()
     * for (category, consent) in consents {
     *     print("Category: \(category), Value: \(consent.value)")
     * }
     * ```
     *
     * Example checking specific category:
     * ```swift
     * let consents = TrustArcConsentImpl.shared.getConsentData()
     * if let analyticsConsent = consents["Analytics"] {
     *     let hasConsent = TrustArcConsentImpl.shared.hasConsentForCategory("Analytics", consent: analyticsConsent)
     *     if hasConsent {
     *         // Enable analytics tracking
     *         Analytics.start()
     *     }
     * }
     * ```
     *
     * @return Dictionary of consent categories and their values
     */
    func getConsentData() -> [String: TAConsent] {
        return TrustArc.sharedInstance.getConsentDataByCategory()
    }

    /**
     * Check if user has consented to a specific category
     *
     * Convenience method to check if the user has granted consent for a specific
     * category (e.g., "Analytics", "Advertising", "Functional").
     *
     * Example usage:
     * ```swift
     * let consents = TrustArcConsentImpl.shared.getConsentData()
     * if let consent = consents["Analytics"] {
     *     if TrustArcConsentImpl.shared.hasConsentForCategory("Analytics", consent: consent) {
     *         // Enable analytics
     *         Analytics.trackEvent("app_opened")
     *     } else {
     *         // Disable analytics
     *         Analytics.disable()
     *     }
     * }
     * ```
     *
     * Example with multiple categories:
     * ```swift
     * let consents = TrustArcConsentImpl.shared.getConsentData()
     *
     * let hasAnalytics = consents["Analytics"].map {
     *     TrustArcConsentImpl.shared.hasConsentForCategory("Analytics", consent: $0)
     * } ?? false
     *
     * let hasAdvertising = consents["Advertising"].map {
     *     TrustArcConsentImpl.shared.hasConsentForCategory("Advertising", consent: $0)
     * } ?? false
     *
     * switch (hasAnalytics, hasAdvertising) {
     * case (true, true):
     *     // Both consents granted
     *     enableAllTracking()
     * case (true, false):
     *     // Only analytics
     *     enableAnalyticsOnly()
     * default:
     *     // No tracking consent
     *     disableTracking()
     * }
     * ```
     *
     * @param category Category name (not used, kept for API consistency)
     * @param consent TAConsent object to check
     * @return true if user has consented, false otherwise
     */
    func hasConsentForCategory(_ category: String, consent: TAConsent) -> Bool {
        // Value "0" indicates required category (always consented)
        if consent.value == "0" {
            return true
        }

        // Check if any domain has consent value "1" (granted)
        if let domains = consent.domains, !domains.isEmpty {
            return domains.contains { domain in
                domain.values.contains("1")
            }
        }

        return false
    }

    // ===== EVENT LISTENER METHODS =====

    /**
     * Register callback for consent changes
     *
     * The callback will be invoked whenever the user modifies their consent preferences.
     * This is the primary way to react to consent changes in your application.
     *
     * Example usage:
     * ```swift
     * TrustArcConsentImpl.shared.onConsentChange { consents in
     *     print("[TrustArc] User consent preferences changed")
     *
     *     // Update analytics based on new consent
     *     if let analyticsConsent = consents["Analytics"] {
     *         let hasConsent = TrustArcConsentImpl.shared.hasConsentForCategory(
     *             "Analytics",
     *             consent: analyticsConsent
     *         )
     *
     *         if hasConsent {
     *             Analytics.enable()
     *         } else {
     *             Analytics.disable()
     *         }
     *     }
     * }
     * ```
     *
     * @param callback Function to call when consent preferences change
     */
    func onConsentChange(callback: @escaping ([String: TAConsent]) -> Void) {
        onConsentChangedCallback = callback
    }

    /**
     * Register callback for SDK initialization completion
     *
     * The callback will be invoked when the SDK finishes initializing.
     * This is useful for updating UI state or triggering post-initialization logic.
     *
     * Example usage:
     * ```swift
     * TrustArcConsentImpl.shared.onSdkInitFinish {
     *     print("[TrustArc] SDK is ready!")
     *     // Update UI or check existing consent
     *     let consents = TrustArcConsentImpl.shared.getConsentData()
     *     self.updateUI(with: consents)
     * }
     * ```
     *
     * @param callback Function to call when SDK initialization completes
     */
    func onSdkInitFinish(callback: @escaping () -> Void) {
        onSdkInitFinishCallback = callback
    }

    // ===== UTILITY METHODS =====

    /**
     * Get root view controller for presenting modal dialogs
     *
     * This helper method retrieves the root view controller from the active window scene.
     * Required for the TrustArc SDK to display the consent management interface.
     *
     * @return The root UIViewController if available, nil otherwise
     */
    @MainActor
    private func getRootViewController() -> UIViewController? {
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
              let rootViewController = windowScene.windows.first?.rootViewController else {
            return nil
        }
        return rootViewController
    }
}

// MARK: - TADelegate (SDK Initialization Callbacks)

/**
 * TADelegate Implementation
 *
 * Handles SDK initialization lifecycle callbacks.
 * These callbacks allow the app to respond to SDK state changes.
 */
@MainActor
extension TrustArcConsentImpl: TADelegate {

    /**
     * Called when the SDK is in an uninitialized state
     */
    func sdkIsNotInitialized() {
        if enableDebugLogs {
            print("[TrustArc] SDK is not initialized")
        }
    }

    /**
     * Called when the SDK initialization process is in progress
     */
    func sdkIsInitializing() {
        if enableDebugLogs {
            print("[TrustArc] SDK is initializing")
        }
    }

    /**
     * Called when the SDK has completed initialization successfully
     *
     * This callback:
     * 1. Checks for existing consent data
     * 2. Updates any registered callbacks
     * 3. Prepares the SDK for user interaction
     */
    func sdkIsInitialized() {
        if enableDebugLogs {
            print("[TrustArc] SDK initialized successfully")

            // Log existing consent data
            let consentData = TrustArc.sharedInstance.getConsentDataByCategory()
            if let consents = consentData as? [String: TAConsent], !consents.isEmpty {
                print("[TrustArc] Found \(consents.count) existing consent categories")
            } else {
                print("[TrustArc] No existing consent data")
            }
        }

        // Notify consent change callback with existing data
        if let consents = TrustArc.sharedInstance.getConsentDataByCategory() as? [String: TAConsent] {
            onConsentChangedCallback?(consents)
        }
    }
}

// MARK: - TAConsentViewControllerDelegate (Consent Dialog Callbacks)

/**
 * TAConsentViewControllerDelegate Implementation
 *
 * Handles callbacks from the TrustArc consent management dialog.
 * Manages the lifecycle of the consent dialog and processes user consent choices.
 */
@MainActor
extension TrustArcConsentImpl: TAConsentViewControllerDelegate {

    /**
     * Called when the consent dialog WebView starts loading
     */
    func consentViewController(_ consentViewController: TAConsentViewController,
                             isLoadingWebView webView: WKWebView) {
        if enableDebugLogs {
            print("[TrustArc] Consent dialog is loading")
        }
    }

    /**
     * Called when the consent dialog WebView finishes loading
     */
    func consentViewController(_ consentViewController: TAConsentViewController,
                             didFinishLoadingWebView webView: WKWebView) {
        if enableDebugLogs {
            print("[TrustArc] Consent dialog finished loading")
        }
    }

    /**
     * Called when the user completes their consent choices and closes the dialog
     *
     * This is the primary callback for processing user consent decisions.
     * The method:
     * 1. Logs the received consent data
     * 2. Dismisses the consent dialog
     * 3. Retrieves the updated consent data from the SDK
     * 4. Notifies registered callbacks
     *
     * @param consentViewController The consent dialog view controller
     * @param consentData Raw consent data from the dialog
     */
    func consentViewController(_ consentViewController: TAConsentViewController,
                             didReceiveConsentData consentData: [String: Any]) {
        if enableDebugLogs {
            print("[TrustArc] Received consent data: \(consentData)")
        }

        // Dismiss the consent dialog with animation
        consentViewController.dismiss(animated: true) {
            // Retrieve structured consent data from SDK
            let consentDataByCategory = TrustArc.sharedInstance.getConsentDataByCategory()

            if self.enableDebugLogs {
                print("[TrustArc] Consent data by category: \(consentDataByCategory)")
            }

            if let consents = consentDataByCategory as? [String: TAConsent], !consents.isEmpty {
                // Notify callback with updated consent data
                self.onConsentChangedCallback?(consents)
            } else {
                if self.enableDebugLogs {
                    print("[TrustArc] No consent data available or invalid format")
                }
            }
        }
    }
}

// MARK: - TAConsentReporterDelegate (Reporting Callbacks)

/**
 * TAConsentReporterDelegate Implementation
 *
 * Handles callbacks related to consent data reporting to TrustArc servers.
 * These callbacks provide visibility into the data transmission process.
 */
@MainActor
extension TrustArcConsentImpl: TAConsentReporterDelegate {

    /**
     * Called when the SDK is about to send consent data to TrustArc servers
     */
    func consentReporterWillSend(report: TAConsentReportInfo) {
        if enableDebugLogs {
            print("[TrustArc] Consent report will be sent")
        }
    }

    /**
     * Called when consent data has been successfully sent to TrustArc servers
     */
    func consentReporterDidSend(report: TAConsentReportInfo) {
        if enableDebugLogs {
            print("[TrustArc] Consent report sent successfully")
        }
    }

    /**
     * Called when sending consent data to TrustArc servers fails
     */
    func consentReporterDidFailSending(report: TAConsentReportInfo) {
        if enableDebugLogs {
            print("[TrustArc] Failed to send consent report")
        }
    }
}


=== Android Kotlin Implementation ===
/**
 * TrustArc Consent Implementation for Android
 *
 * This file provides a simplified interface for integrating the TrustArc Mobile Consent SDK
 * into your Android application. It handles SDK initialization, consent management,
 * and event callbacks.
 *
 * Quick Start:
 * 1. Initialize in your Application class: TrustArcConsentImpl.initialize(this)
 * 2. Show consent dialog: TrustArcConsentImpl.openCm()
 * 3. Get consent status: TrustArcConsentImpl.getConsentData()
 *
 * @author TrustArc Mobile Team
 * @version 1.0.0
 */

import android.app.Application
import android.util.Log
import com.truste.androidmobileconsentsdk.SdkMode
import com.truste.androidmobileconsentsdk.TrustArc
import com.truste.androidmobileconsentsdk.vendors.TAConsent

/**
 * TrustArc Consent Manager Implementation
 *
 * Provides a streamlined interface for TrustArc consent management operations
 * including SDK initialization, consent dialog presentation, and status retrieval.
 *
 * This singleton object manages the TrustArc SDK lifecycle and provides convenient
 * methods for consent operations throughout your application.
 */
object TrustArcConsentImpl {

    private const val TAG = "TrustArcConsent"

    // ===== CONFIGURATION =====
    /// TrustArc domain name for consent management
    /// This will be replaced during CLI installation with your specific domain
    private const val DOMAIN = "__TRUSTARC_DOMAIN_PLACEHOLDER__"

    /// SDK mode: Standard for regular operation, IAB for TCF compliance
    private val SDK_MODE = SdkMode.Standard

    /// Enable debug logging for development and troubleshooting
    private const val ENABLE_DEBUG_LOGS = true

    // ===== SDK INSTANCE =====
    private lateinit var trustArc: TrustArc

    // ===== STATE TRACKING =====
    private var isInitialized = false

    // ===== EVENT CALLBACKS =====
    /// Callback function for consent changes
    private var onConsentChangedCallback: ((Map<String, TAConsent>) -> Unit)? = null

    /// Callback function for Google consent changes
    private var onGoogleConsentChangedCallback: ((Map<String, String>) -> Unit)? = null

    /// Callback function for SDK initialization completion
    private var onSdkInitFinishCallback: (() -> Unit)? = null

    // ===== INITIALIZATION METHODS =====

    /**
     * Initialize the TrustArc SDK
     *
     * This is the main entry point for integrating TrustArc consent management.
     * Call this method once when your app starts, typically in your Application class's
     * onCreate() method.
     *
     * Example usage in Application class:
     * ```kotlin
     * class MyApplication : Application() {
     *     override fun onCreate() {
     *         super.onCreate()
     *         TrustArcConsentImpl.initialize(this)
     *     }
     * }
     * ```
     *
     * Example usage with Hilt/Dagger:
     * ```kotlin
     * @HiltAndroidApp
     * class MyApplication : Application() {
     *     override fun onCreate() {
     *         super.onCreate()
     *         TrustArcConsentImpl.initialize(this)
     *     }
     * }
     * ```
     *
     * @param application Application context
     */
    fun initialize(application: Application) {
        if (isInitialized) {
            Log.d(TAG, "TrustArc already initialized, skipping")
            return
        }

        if (ENABLE_DEBUG_LOGS) {
            Log.d(TAG, "Initializing TrustArc SDK with domain: $DOMAIN")
        }

        try {
            // Create TrustArc instance with SDK mode
            trustArc = TrustArc(application, SDK_MODE)

            // Enable debug logging if configured
            trustArc.enableDebugLog(ENABLE_DEBUG_LOGS)

            // Optional: Configure GDPR detection
            // Uncomment to disable automatic GDPR detection based on IP
            // trustArc.useGdprDetection(false)

            // Start the SDK with domain configuration
            trustArc.start(domainName = DOMAIN)

            // Register consent change listener
            trustArc.addConsentListener { consents ->
                handleConsentChanged(consents)
            }

            // Register Google consent listener
            trustArc.addGoogleConsentListener { googleConsents ->
                handleGoogleConsentChanged(googleConsents)
            }

            isInitialized = true

            if (ENABLE_DEBUG_LOGS) {
                Log.d(TAG, "TrustArc SDK initialized successfully")
            }

            // Notify initialization completion
            onSdkInitFinishCallback?.invoke()

        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize TrustArc SDK", e)
            throw e
        }
    }

    // ===== CONSENT MANAGEMENT METHODS =====

    /**
     * Open the TrustArc consent management dialog
     *
     * Presents the consent preferences UI to the user, allowing them to
     * review and modify their consent choices.
     *
     * Example usage in an Activity:
     * ```kotlin
     * class MainActivity : AppCompatActivity() {
     *     private fun showPrivacySettings() {
     *         TrustArcConsentImpl.openCm()
     *     }
     * }
     * ```
     *
     * Example usage in a Fragment:
     * ```kotlin
     * class SettingsFragment : Fragment() {
     *     private fun manageConsent() {
     *         TrustArcConsentImpl.openCm()
     *     }
     * }
     * ```
     *
     * Example usage in Jetpack Compose:
     * ```kotlin
     * @Composable
     * fun PrivacySettingsButton() {
     *     Button(onClick = { TrustArcConsentImpl.openCm() }) {
     *         Text("Manage Privacy")
     *     }
     * }
     * ```
     *
     * The SDK must be initialized before calling this method.
     */
    fun openCm() {
        if (!::trustArc.isInitialized) {
            Log.e(TAG, "TrustArc not initialized. Call initialize() first")
            return
        }

        if (ENABLE_DEBUG_LOGS) {
            Log.d(TAG, "Opening consent management dialog")
        }

        try {
            trustArc.openCM()
        } catch (e: Exception) {
            Log.e(TAG, "Failed to open consent dialog", e)
        }
    }

    /**
     * Get current consent data organized by category
     *
     * Retrieves the user's current consent preferences organized by category.
     * Returns a map where keys are category names and values contain consent details.
     *
     * Example usage:
     * ```kotlin
     * val consents = TrustArcConsentImpl.getConsentData()
     * consents.forEach { (category, consent) ->
     *     Log.d("Consent", "Category: $category, Value: ${consent.value}")
     * }
     * ```
     *
     * Example checking specific category:
     * ```kotlin
     * val analyticsConsent = TrustArcConsentImpl.getConsentData()["Analytics"]
     * if (analyticsConsent != null) {
     *     val hasConsent = TrustArcConsentImpl.hasConsentForCategory("Analytics")
     *     if (hasConsent) {
     *         // Enable analytics tracking
     *         Analytics.initialize()
     *     }
     * }
     * ```
     *
     * @return Map of consent categories and their values, or empty map if not initialized
     */
    fun getConsentData(): Map<String, TAConsent> {
        if (!::trustArc.isInitialized) {
            Log.e(TAG, "TrustArc not initialized. Call initialize() first")
            return emptyMap()
        }

        return try {
            trustArc.getConsentDataByCategory()
        } catch (e: Exception) {
            Log.e(TAG, "Failed to get consent data", e)
            emptyMap()
        }
    }

    /**
     * Get Google Consent Mode data
     *
     * Retrieves consent data formatted for Google Consent Mode v2.
     * This is useful if your app uses Google services and needs to handle
     * Google consent separately.
     *
     * Example usage:
     * ```kotlin
     * val googleConsents = TrustArcConsentImpl.getGoogleConsents()
     * googleConsents.forEach { (key, value) ->
     *     Log.d("GoogleConsent", "$key: $value")
     * }
     * ```
     *
     * Example with Firebase:
     * ```kotlin
     * val googleConsents = TrustArcConsentImpl.getGoogleConsents()
     * val adStorageConsent = googleConsents["ad_storage"] == "granted"
     * val analyticsConsent = googleConsents["analytics_storage"] == "granted"
     *
     * FirebaseAnalytics.getInstance(context).setConsent {
     *     adStorage(if (adStorageConsent) GRANTED else DENIED)
     *     analyticsStorage(if (analyticsConsent) GRANTED else DENIED)
     * }
     * ```
     *
     * @return Map of Google consent keys and their values
     */
    fun getGoogleConsents(): Map<String, String> {
        if (!::trustArc.isInitialized) {
            Log.e(TAG, "TrustArc not initialized. Call initialize() first")
            return emptyMap()
        }

        return try {
            trustArc.getGoogleConsents()
        } catch (e: Exception) {
            Log.e(TAG, "Failed to get Google consents", e)
            emptyMap()
        }
    }

    /**
     * Check if user has consented to a specific category
     *
     * Convenience method to check if the user has granted consent for a specific
     * category (e.g., "Analytics", "Advertising", "Functional").
     *
     * Example usage:
     * ```kotlin
     * if (TrustArcConsentImpl.hasConsentForCategory("Analytics")) {
     *     // Enable analytics tracking
     *     Analytics.trackEvent("app_opened")
     * } else {
     *     // Analytics disabled
     *     Analytics.disable()
     * }
     * ```
     *
     * Example with multiple categories:
     * ```kotlin
     * val hasAnalytics = TrustArcConsentImpl.hasConsentForCategory("Analytics")
     * val hasAdvertising = TrustArcConsentImpl.hasConsentForCategory("Advertising")
     *
     * when {
     *     hasAnalytics && hasAdvertising -> {
     *         // Both consents granted
     *         enableAllTracking()
     *     }
     *     hasAnalytics -> {
     *         // Only analytics
     *         enableAnalyticsOnly()
     *     }
     *     else -> {
     *         // No tracking consent
     *         disableTracking()
     *     }
     * }
     * ```
     *
     * @param category Category name to check
     * @return true if user has consented, false otherwise
     */
    fun hasConsentForCategory(category: String): Boolean {
        val consentData = getConsentData()
        val categoryConsent = consentData[category] ?: return false

        // Check if category has consent
        return when {
            // Value "0" indicates required category (always consented)
            categoryConsent.value == "0" -> true
            // No domains means no consent data available
            categoryConsent.domains.isNullOrEmpty() -> false
            // Check if any domain has value "1" (consented)
            else -> categoryConsent.domains!!.any { it.values.contains("1") }
        }
    }

    // ===== EVENT LISTENER METHODS =====

    /**
     * Register callback for consent changes
     *
     * The callback will be invoked whenever the user modifies their consent preferences.
     * This is the primary way to react to consent changes in your application.
     *
     * Example usage:
     * ```kotlin
     * TrustArcConsentImpl.onConsentChange { consents ->
     *     Log.d("Consent", "User consent preferences changed")
     *
     *     // Update analytics based on new consent
     *     val hasAnalyticsConsent = consents["Analytics"]?.let { consent ->
     *         consent.value == "0" || consent.domains?.any {
     *             it.values.contains("1")
     *         } == true
     *     } ?: false
     *
     *     if (hasAnalyticsConsent) {
     *         Analytics.enable()
     *     } else {
     *         Analytics.disable()
     *     }
     * }
     * ```
     *
     * @param callback Function to call when consent preferences change
     */
    fun onConsentChange(callback: (Map<String, TAConsent>) -> Unit) {
        onConsentChangedCallback = callback
    }

    /**
     * Register callback for Google consent changes
     *
     * The callback will be invoked when Google-specific consent preferences change.
     * This is useful if your app uses Google services and needs to handle
     * Google consent separately.
     *
     * Example usage:
     * ```kotlin
     * TrustArcConsentImpl.onGoogleConsentChange { googleConsents ->
     *     Log.d("GoogleConsent", "Google consent preferences changed")
     *
     *     // Update Google services configuration
     *     val adStorageGranted = googleConsents["ad_storage"] == "granted"
     *     val analyticsGranted = googleConsents["analytics_storage"] == "granted"
     *
     *     // Configure Firebase Analytics
     *     FirebaseAnalytics.getInstance(context).setConsent {
     *         adStorage(if (adStorageGranted) GRANTED else DENIED)
     *         analyticsStorage(if (analyticsGranted) GRANTED else DENIED)
     *     }
     * }
     * ```
     *
     * @param callback Function to call when Google consent changes
     */
    fun onGoogleConsentChange(callback: (Map<String, String>) -> Unit) {
        onGoogleConsentChangedCallback = callback
    }

    /**
     * Register callback for SDK initialization completion
     *
     * The callback will be invoked when the SDK finishes initializing.
     * This is useful for updating UI state or triggering post-initialization logic.
     *
     * Example usage:
     * ```kotlin
     * TrustArcConsentImpl.onSdkInitFinish {
     *     Log.d("TrustArc", "SDK is ready!")
     *     // Update UI or check existing consent
     *     val consents = TrustArcConsentImpl.getConsentData()
     *     updateUIWithConsents(consents)
     * }
     * ```
     *
     * @param callback Function to call when SDK initialization completes
     */
    fun onSdkInitFinish(callback: () -> Unit) {
        onSdkInitFinishCallback = callback
    }

    // ===== STATUS QUERY METHODS =====

    /**
     * Check if SDK is currently initialized
     *
     * @return true if SDK is initialized and ready to use
     */
    fun isInitialized(): Boolean {
        return isInitialized
    }

    /**
     * Get the configured domain name
     *
     * @return TrustArc domain configured for this SDK instance
     */
    fun getDomain(): String {
        return DOMAIN
    }

    // ===== INTERNAL EVENT HANDLERS =====

    /**
     * Internal handler for consent changes
     *
     * Called by the SDK when consent data changes.
     * Logs the change and notifies registered callbacks.
     *
     * @param consents Updated consent data
     */
    private fun handleConsentChanged(consents: Map<String, TAConsent>) {
        if (ENABLE_DEBUG_LOGS) {
            Log.d(TAG, "Consent data changed: ${consents.size} categories")
            consents.forEach { (key, value) ->
                Log.d(TAG, "  Category: $key, Value: ${value.value}")
            }
        }

        // Notify callback
        onConsentChangedCallback?.invoke(consents)
    }

    /**
     * Internal handler for Google consent changes
     *
     * Called by the SDK when Google consent data changes.
     * Logs the change and notifies registered callbacks.
     *
     * @param googleConsents Updated Google consent data
     */
    private fun handleGoogleConsentChanged(googleConsents: Map<String, String>) {
        if (ENABLE_DEBUG_LOGS) {
            Log.d(TAG, "Google consent data changed")
            googleConsents.forEach { (key, value) ->
                Log.d(TAG, "  $key: $value")
            }
        }

        // Notify callback
        onGoogleConsentChangedCallback?.invoke(googleConsents)
    }
}


=== React Native TypeScript Implementation ===
import { NativeModules, NativeEventEmitter, Platform } from 'react-native';

const { TrustArcMobileSdk } = NativeModules;

/**
 * TrustArc Consent Manager Implementation for React Native
 *
 * This singleton class manages the TrustArc SDK lifecycle and consent operations
 * across both iOS and Android platforms using the native SDK modules.
 *
 * Usage:
 * 1. Initialize the SDK (typically in App.tsx or _layout.tsx):
 *    await TrustArcConsentImpl.getInstance().initialize();
 *
 * 2. Show consent dialog:
 *    TrustArcConsentImpl.getInstance().openCm();
 *
 * 3. Get consent data:
 *    const consents = await TrustArcConsentImpl.getInstance().getConsentData();
 *
 * 4. Listen for consent changes:
 *    TrustArcConsentImpl.getInstance().onConsentChange((data) => {
 *      console.log('Consent changed:', data);
 *    });
 */
class TrustArcConsentImpl {
  private static instance: TrustArcConsentImpl;
  private eventEmitter: NativeEventEmitter;
  private consentChangeListeners: Array<(data: any) => void> = [];
  private googleConsentChangeListeners: Array<(data: any) => void> = [];
  private sdkInitListeners: Array<() => void> = [];
  private isInitialized = false;
  private isReady = false;

  // Configuration - update with your domain
  private readonly DOMAIN = '__TRUSTARC_DOMAIN_PLACEHOLDER__';
  private readonly IP_ADDRESS = ''; // Optional: set user IP for GDPR detection
  private readonly LANGUAGE = 'en'; // Optional: set language code
  private readonly ENABLE_DEBUG_LOGS = true;

  private constructor() {
    if (!TrustArcMobileSdk) {
      throw new Error(
        'TrustArcMobileSdk native module not found. Make sure the SDK is properly installed and linked.'
      );
    }

    this.eventEmitter = new NativeEventEmitter(TrustArcMobileSdk);
    this.setupEventListeners();
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): TrustArcConsentImpl {
    if (!TrustArcConsentImpl.instance) {
      TrustArcConsentImpl.instance = new TrustArcConsentImpl();
    }
    return TrustArcConsentImpl.instance;
  }

  /**
   * Setup native event listeners
   */
  private setupEventListeners(): void {
    // Listen for consent changes
    this.eventEmitter.addListener('onConsentChanges', (data) => {
      if (this.ENABLE_DEBUG_LOGS) {
        console.log('[TrustArc] Consent data changed:', data);
      }
      this.consentChangeListeners.forEach((listener) => listener(data));
    });

    // Listen for Google consent changes
    this.eventEmitter.addListener('onGoogleConsentChanges', (data) => {
      if (this.ENABLE_DEBUG_LOGS) {
        console.log('[TrustArc] Google consent data changed:', data);
      }
      this.googleConsentChangeListeners.forEach((listener) => listener(data));
    });

    // Listen for SDK initialization completion
    this.eventEmitter.addListener('onSdkInitFinish', () => {
      if (this.ENABLE_DEBUG_LOGS) {
        console.log('[TrustArc] SDK initialization finished');
      }
      this.isReady = true;
      this.sdkInitListeners.forEach((listener) => listener());
    });
  }

  /**
   * Initialize TrustArc SDK
   * Call this method once when your app starts
   *
   * @returns Promise<void>
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      console.log('[TrustArc] Already initialized, skipping');
      return;
    }

    try {
      console.log(`[TrustArc] Initializing SDK with domain: ${this.DOMAIN}`);

      // Initialize the native SDK
      await TrustArcMobileSdk.initialize();

      // Start the SDK with configuration
      await TrustArcMobileSdk.start(this.DOMAIN, this.IP_ADDRESS, this.LANGUAGE);

      this.isInitialized = true;
      console.log('[TrustArc] SDK initialized successfully');

      // Note: The SDK may automatically show consent UI if needed
      // The native layer handles this automatically via the shouldShowConsentUI callback
    } catch (error) {
      console.error('[TrustArc] Initialization failed:', error);
      throw error;
    }
  }

  /**
   * Open consent management dialog
   * This displays the TrustArc consent UI to the user
   *
   * @returns Promise<void>
   */
  public async openCm(): Promise<void> {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      console.log('[TrustArc] Opening consent management dialog');
      await TrustArcMobileSdk.openCM();
    } catch (error) {
      console.error('[TrustArc] Failed to open consent dialog:', error);
      throw error;
    }
  }

  /**
   * Get current consent data by category
   *
   * @returns Promise<Record<string, any>> Map of consent categories and their values
   */
  public async getConsentData(): Promise<Record<string, any>> {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      const consentData = await TrustArcMobileSdk.getConsentDataByCategory();
      return consentData || {};
    } catch (error) {
      console.error('[TrustArc] Failed to get consent data:', error);
      return {};
    }
  }

  /**
   * Get consent value for a specific tracker
   *
   * @param trackerId Tracker ID to check
   * @returns Promise<string | null> Consent value for the tracker
   */
  public async getConsentValue(trackerId: string): Promise<string | null> {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      return await TrustArcMobileSdk.getConsentValue(trackerId);
    } catch (error) {
      console.error(`[TrustArc] Failed to get consent value for tracker ${trackerId}:`, error);
      return null;
    }
  }

  /**
   * Get IAB TCF consent string
   * Only applicable if SDK is configured in IAB TCF mode
   *
   * @returns Promise<string | null> TCF consent string
   */
  public async getTcfString(): Promise<string | null> {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      return await TrustArcMobileSdk.getTcfString();
    } catch (error) {
      console.error('[TrustArc] Failed to get TCF string:', error);
      return null;
    }
  }

  /**
   * Get Google Consent Mode data
   *
   * @returns Promise<Record<string, any>> Google consent data
   */
  public async getGoogleConsents(): Promise<Record<string, any>> {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      const googleConsents = await TrustArcMobileSdk.getGoogleConsents();
      return googleConsents || {};
    } catch (error) {
      console.error('[TrustArc] Failed to get Google consents:', error);
      return {};
    }
  }

  /**
   * Get web script for web view integration
   *
   * @returns Promise<string | null> Web script
   */
  public async getWebScript(): Promise<string | null> {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      return await TrustArcMobileSdk.getWebScript();
    } catch (error) {
      console.error('[TrustArc] Failed to get web script:', error);
      return null;
    }
  }

  /**
   * Get shared preferences data
   * Platform-specific consent storage
   *
   * @returns Promise<Record<string, any>> Shared preferences data
   */
  public async getSharedPreferences(): Promise<Record<string, any>> {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      const preferences = await TrustArcMobileSdk.getSharedPreferences();
      return preferences || {};
    } catch (error) {
      console.error('[TrustArc] Failed to get shared preferences:', error);
      return {};
    }
  }

  /**
   * Check if user has consented to a specific category
   *
   * @param category Category name to check
   * @returns Promise<boolean> true if user has consented, false otherwise
   */
  public async hasConsentForCategory(category: string): Promise<boolean> {
    const consentData = await this.getConsentData();
    const categoryConsent = consentData[category];

    if (!categoryConsent) {
      return false;
    }

    // Check if category has consent
    // Value "0" typically means required/always consented
    if (categoryConsent.value === '0') {
      return true;
    }

    // Check if any domain has consent
    if (categoryConsent.domains && Array.isArray(categoryConsent.domains)) {
      return categoryConsent.domains.some((domain: any) =>
        domain.values && domain.values.includes('1')
      );
    }

    return false;
  }

  /**
   * Register a listener for consent changes
   *
   * @param listener Callback function to be called when consent changes
   * @returns Function to unregister the listener
   */
  public onConsentChange(listener: (data: any) => void): () => void {
    this.consentChangeListeners.push(listener);
    return () => {
      this.consentChangeListeners = this.consentChangeListeners.filter((l) => l !== listener);
    };
  }

  /**
   * Register a listener for Google consent changes
   *
   * @param listener Callback function to be called when Google consent changes
   * @returns Function to unregister the listener
   */
  public onGoogleConsentChange(listener: (data: any) => void): () => void {
    this.googleConsentChangeListeners.push(listener);
    return () => {
      this.googleConsentChangeListeners = this.googleConsentChangeListeners.filter(
        (l) => l !== listener
      );
    };
  }

  /**
   * Register a listener for SDK initialization completion
   *
   * @param listener Callback function to be called when SDK initialization finishes
   * @returns Function to unregister the listener
   */
  public onSdkInitFinish(listener: () => void): () => void {
    this.sdkInitListeners.push(listener);
    return () => {
      this.sdkInitListeners = this.sdkInitListeners.filter((l) => l !== listener);
    };
  }

  /**
   * Check if SDK is initialized
   */
  public getIsInitialized(): boolean {
    return this.isInitialized;
  }

  /**
   * Check if SDK is ready (initialization complete)
   */
  public getIsReady(): boolean {
    return this.isReady;
  }

  /**
   * Remove all event listeners
   * Call this when your app is being destroyed
   */
  public cleanup(): void {
    this.eventEmitter.removeAllListeners('onConsentChanges');
    this.eventEmitter.removeAllListeners('onGoogleConsentChanges');
    this.eventEmitter.removeAllListeners('onSdkInitFinish');
    this.consentChangeListeners = [];
    this.googleConsentChangeListeners = [];
    this.sdkInitListeners = [];
  }
}

// Export singleton instance for convenience
export default TrustArcConsentImpl.getInstance();

// Also export the class for type-safe access
export { TrustArcConsentImpl };


=== React Native JavaScript Implementation ===
import { NativeModules, NativeEventEmitter } from 'react-native';
import { SdkMode, TrustArcSdk } from '@trustarc/trustarc-react-native-consent-sdk';

/**
 * TrustArc Consent Manager Implementation for React Native
 *
 * This singleton class manages the TrustArc SDK lifecycle and consent operations
 * across both iOS and Android platforms using the native SDK modules.
 *
 * Usage:
 * 1. Initialize the SDK (typically in App.js or _layout.js):
 *    await TrustArcConsentImpl.getInstance().initialize();
 *
 * 2. Show consent dialog:
 *    TrustArcConsentImpl.getInstance().openCm();
 *
 * 3. Get consent data:
 *    const consents = await TrustArcConsentImpl.getInstance().getConsentData();
 *
 * 4. Listen for consent changes:
 *    TrustArcConsentImpl.getInstance().onConsentChange((data) => {
 *      console.log('Consent changed:', data);
 *    });
 */
class TrustArcConsentImpl {
  static instance;

  constructor() {
    this.consentChangeListeners = [];
    this.googleConsentChangeListeners = [];
    this.sdkInitListeners = [];
    this.isInitialized = false;
    this.isReady = false;

    // Configuration - update with your domain
    this.DOMAIN = 'mac_trustarc.com';
    this.IP_ADDRESS = ''; // Optional: set user IP for GDPR detection
    this.LANGUAGE = 'en'; // Optional: set language code
    this.ENABLE_DEBUG_LOGS = true;

    // Only initialize SDK components if native module is available
    if (NativeModules.TrustArcMobileSdk) {
      this.trustArcSdk = new TrustArcSdk();
      this.eventEmitter = new NativeEventEmitter(NativeModules.TrustArcMobileSdk);
      this.setupEventListeners();
    } else {
      console.warn('[TrustArc] Native module not available. SDK features will be disabled.');
      this.trustArcSdk = null;
      this.eventEmitter = null;
    }
  }

  /**
   * Get singleton instance
   */
  static getInstance() {
    if (!TrustArcConsentImpl.instance) {
      TrustArcConsentImpl.instance = new TrustArcConsentImpl();
    }
    return TrustArcConsentImpl.instance;
  }

  /**
   * Setup native event listeners
   */
  setupEventListeners() {
    // Listen for consent changes
    this.eventEmitter.addListener('onConsentChanges', (data) => {
      if (this.ENABLE_DEBUG_LOGS) {
        console.log('[TrustArc] Consent data changed:', data);
      }
      this.consentChangeListeners.forEach((listener) => listener(data));
    });

    // Listen for Google consent changes
    this.eventEmitter.addListener('onGoogleConsentChanges', (data) => {
      if (this.ENABLE_DEBUG_LOGS) {
        console.log('[TrustArc] Google consent data changed:', data);
      }
      this.googleConsentChangeListeners.forEach((listener) => listener(data));
    });

    // Listen for SDK initialization completion
    this.eventEmitter.addListener('onSdkInitFinish', () => {
      if (this.ENABLE_DEBUG_LOGS) {
        console.log('[TrustArc] SDK initialization finished');
      }
      this.isReady = true;
      this.sdkInitListeners.forEach((listener) => listener());
    });
  }

  /**
   * Initialize TrustArc SDK
   * Call this method once when your app starts
   *
   * @returns Promise<void>
   */
  async initialize() {
    if (!this.trustArcSdk) {
      console.warn('[TrustArc] SDK not available. Skipping initialization.');
      return;
    }

    if (this.isInitialized) {
      console.log('[TrustArc] Already initialized, skipping');
      return;
    }

    try {
      console.log(`[TrustArc] Initializing SDK with domain: ${this.DOMAIN}`);

      await this.trustArcSdk.enableDebugLog(this.ENABLE_DEBUG_LOGS);

      // Initialize the native SDK
      await this.trustArcSdk.initialize(SdkMode.standard);

      // Start the SDK with configuration
      await this.trustArcSdk.start(this.DOMAIN, this.IP_ADDRESS, this.LANGUAGE);

      this.isInitialized = true;
      console.log('[TrustArc] SDK initialized successfully');

      // Note: The SDK may automatically show consent UI if needed
      // The native layer handles this automatically via the shouldShowConsentUI callback
    } catch (error) {
      console.error('[TrustArc] Initialization failed:', error);
      throw error;
    }
  }

  /**
   * Open consent management dialog
   * This displays the TrustArc consent UI to the user
   *
   * @returns Promise<void>
   */
  async openCm() {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      console.log('[TrustArc] Opening consent management dialog');
      await this.trustArcSdk.openCM();
    } catch (error) {
      console.error('[TrustArc] Failed to open consent dialog:', error);
      throw error;
    }
  }

  /**
   * Get current consent data by category
   *
   * @returns Promise<Object> Map of consent categories and their values
   */
  async getConsentData() {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      const consentData = await this.trustArcSdk.getConsentDataByCategory();
      return consentData || {};
    } catch (error) {
      console.error('[TrustArc] Failed to get consent data:', error);
      return {};
    }
  }

  /**
   * Get consent value for a specific tracker
   *
   * @param {string} trackerId Tracker ID to check
   * @returns Promise<string | null> Consent value for the tracker
   */
  async getConsentValue(trackerId) {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      return await this.trustArcSdk.getConsentValue(trackerId);
    } catch (error) {
      console.error(`[TrustArc] Failed to get consent value for tracker ${trackerId}:`, error);
      return null;
    }
  }

  /**
   * Get IAB TCF consent string
   * Only applicable if SDK is configured in IAB TCF mode
   *
   * @returns Promise<string | null> TCF consent string
   */
  async getTcfString() {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      return await this.trustArcSdk.getTcfString();
    } catch (error) {
      console.error('[TrustArc] Failed to get TCF string:', error);
      return null;
    }
  }

  /**
   * Get Google Consent Mode data
   *
   * @returns Promise<Object> Google consent data
   */
  async getGoogleConsents() {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      const googleConsents = await this.trustArcSdk.getGoogleConsents();
      return googleConsents || {};
    } catch (error) {
      console.error('[TrustArc] Failed to get Google consents:', error);
      return {};
    }
  }

  /**
   * Get web script for web view integration
   *
   * @returns Promise<string | null> Web script
   */
  async getWebScript() {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      return await this.trustArcSdk.getWebScript();
    } catch (error) {
      console.error('[TrustArc] Failed to get web script:', error);
      return null;
    }
  }

  /**
   * Get shared preferences data
   * Platform-specific consent storage
   *
   * @returns Promise<Object> Shared preferences data
   */
  async getSharedPreferences() {
    if (!this.isInitialized) {
      throw new Error('TrustArc not initialized. Call initialize() first');
    }

    try {
      const preferences = await this.trustArcSdk.getSharedPreferences();
      return preferences || {};
    } catch (error) {
      console.error('[TrustArc] Failed to get shared preferences:', error);
      return {};
    }
  }

  /**
   * Check if user has consented to a specific category
   *
   * @param {string} category Category name to check
   * @returns Promise<boolean> true if user has consented, false otherwise
   */
  async hasConsentForCategory(category) {
    const consentData = await this.getConsentData();
    const categoryConsent = consentData[category];

    if (!categoryConsent) {
      return false;
    }

    // Check if category has consent
    // Value "0" typically means required/always consented
    if (categoryConsent.value === '0') {
      return true;
    }

    // Check if any domain has consent
    if (categoryConsent.domains && Array.isArray(categoryConsent.domains)) {
      return categoryConsent.domains.some((domain) =>
        domain.values && domain.values.includes('1')
      );
    }

    return false;
  }

  /**
   * Register a listener for consent changes
   *
   * @param {Function} listener Callback function to be called when consent changes
   * @returns Function to unregister the listener
   */
  onConsentChange(listener) {
    this.consentChangeListeners.push(listener);
    return () => {
      this.consentChangeListeners = this.consentChangeListeners.filter((l) => l !== listener);
    };
  }

  /**
   * Register a listener for Google consent changes
   *
   * @param {Function} listener Callback function to be called when Google consent changes
   * @returns Function to unregister the listener
   */
  onGoogleConsentChange(listener) {
    this.googleConsentChangeListeners.push(listener);
    return () => {
      this.googleConsentChangeListeners = this.googleConsentChangeListeners.filter(
        (l) => l !== listener
      );
    };
  }

  /**
   * Register a listener for SDK initialization completion
   *
   * @param {Function} listener Callback function to be called when SDK initialization finishes
   * @returns Function to unregister the listener
   */
  onSdkInitFinish(listener) {
    this.sdkInitListeners.push(listener);
    return () => {
      this.sdkInitListeners = this.sdkInitListeners.filter((l) => l !== listener);
    };
  }

  /**
   * Check if SDK is initialized
   */
  getIsInitialized() {
    return this.isInitialized;
  }

  /**
   * Check if SDK is ready (initialization complete)
   */
  getIsReady() {
    return this.isReady;
  }

  /**
   * Remove all event listeners
   * Call this when your app is being destroyed
   */
  cleanup() {
    this.eventEmitter.removeAllListeners('onConsentChanges');
    this.eventEmitter.removeAllListeners('onGoogleConsentChanges');
    this.eventEmitter.removeAllListeners('onSdkInitFinish');
    this.consentChangeListeners = [];
    this.googleConsentChangeListeners = [];
    this.sdkInitListeners = [];
  }
}

// Export the class as default
export default TrustArcConsentImpl;

// Also export a named export for the class
export { TrustArcConsentImpl };

=== Flutter Dart Implementation ===
/// TrustArc Consent Implementation for Flutter
///
/// This file provides a simplified interface for integrating the TrustArc Mobile Consent SDK
/// into your Flutter application. It handles SDK initialization, consent management,
/// and event subscriptions.
///
/// Quick Start:
/// 1. Import this file: import 'TrustArcConsentImpl.dart';
/// 2. Initialize in your app: TrustArcConsentImpl.initialize(context);
/// 3. Show consent dialog: TrustArcConsentImpl.openCm();
///
/// @author TrustArc Mobile Team
/// @version 1.0.0

import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_trustarc_mobile_consent_sdk/flutter_trustarc_mobile_consent_sdk.dart';

/// TrustArc Consent Manager Implementation
///
/// Provides a streamlined interface for TrustArc consent management operations
/// including SDK initialization, consent dialog presentation, and status retrieval.
class TrustArcConsentImpl {
  // === CONFIGURATION ===
  /// TrustArc domain name for consent management
  /// This will be replaced during CLI installation with your specific domain
  static const String domain = "__TRUSTARC_DOMAIN_PLACEHOLDER__";

  // === SDK INSTANCE ===
  /// Singleton instance of the TrustArc Mobile Consent SDK
  static final FlutterTrustarcMobileConsentSdk _mobileSdk =
      FlutterTrustarcMobileConsentSdk();

  // === STATE TRACKING ===
  /// Track SDK initialization status
  static bool _isInitialized = false;

  /// Track SDK loading status
  static bool _isLoading = false;

  // === EVENT CALLBACKS ===
  /// Callback function for SDK initialization completion
  static Function? _onSdkInitFinishCallback;

  /// Callback function for consent changes
  static Function? _onConsentChangesCallback;

  /// Callback function for Google consent changes
  static Function? _onGoogleConsentChangesCallback;

  // === INITIALIZATION METHODS ===

  /// Initialize the TrustArc SDK
  ///
  /// This is the main entry point for integrating TrustArc consent management.
  /// Call this method once when your app starts, typically in your main widget's
  /// initState or in a Provider/Bloc initialization.
  ///
  /// Example usage in a StatefulWidget:
  /// ```dart
  /// @override
  /// void initState() {
  ///   super.initState();
  ///   WidgetsBinding.instance.addPostFrameCallback((_) {
  ///     TrustArcConsentImpl.initialize(context);
  ///   });
  /// }
  /// ```
  ///
  /// Example usage in main.dart:
  /// ```dart
  /// void main() async {
  ///   WidgetsFlutterBinding.ensureInitialized();
  ///   runApp(MyApp());
  /// }
  ///
  /// class MyApp extends StatelessWidget {
  ///   @override
  ///   Widget build(BuildContext context) {
  ///     // Initialize after first frame
  ///     WidgetsBinding.instance.addPostFrameCallback((_) {
  ///       TrustArcConsentImpl.initialize(context);
  ///     });
  ///     return MaterialApp(...);
  ///   }
  /// }
  /// ```
  ///
  /// @param context BuildContext for showing toast notifications (optional)
  /// @returns Future<void>
  static Future<void> initialize([BuildContext? context]) async {
    if (_isLoading) {
      debugPrint('TrustArc: SDK initialization already in progress');
      return;
    }

    try {
      // Check if SDK is already initialized
      final isInitialized = await _mobileSdk.isSdkInitialized();
      if (isInitialized) {
        _isInitialized = true;
        debugPrint('TrustArc: SDK already initialized');
        _onSdkInitFinishCallback?.call();
        return;
      }

      // Setup event subscriptions
      _setupEventSubscriptions();

      // Start initialization
      _isLoading = true;
      debugPrint('TrustArc: Initializing SDK with domain: $domain');

      // Initialize SDK in standard mode (production mode)
      await _mobileSdk.initialize(SdkMode.standard);

      // Start SDK with domain configuration
      // Empty IP and locale strings allow SDK to auto-detect
      await _mobileSdk.start(domain, "", "");

      debugPrint('TrustArc: SDK initialization started successfully');
    } catch (error) {
      _isLoading = false;
      _isInitialized = false;
      debugPrint('TrustArc: Error initializing SDK: $error');
      rethrow;
    }
  }

  /// Setup event subscriptions for SDK callbacks
  ///
  /// Configures the SDK to notify the application of important events:
  /// - SDK initialization completion
  /// - User consent preference changes
  /// - Google-specific consent updates
  ///
  /// These subscriptions are set up once during initialization and remain
  /// active for the lifetime of the application.
  static void _setupEventSubscriptions() {
    _mobileSdk.subscribe(
      onSdkInitFinish: () {
        _isInitialized = true;
        _isLoading = false;
        debugPrint('TrustArc: SDK initialization finished');
        _onSdkInitFinishCallback?.call();
      },
      onConsentChanges: () {
        debugPrint('TrustArc: Consent preferences changed');
        _onConsentChangesCallback?.call();
      },
      onGoogleConsentChanges: () {
        debugPrint('TrustArc: Google consent preferences changed');
        _onGoogleConsentChangesCallback?.call();
      },
    );
  }

  // === CONSENT MANAGEMENT METHODS ===

  /// Open the TrustArc Consent Manager dialog
  ///
  /// Presents the consent preferences UI to the user, allowing them to
  /// review and modify their consent choices.
  ///
  /// Example usage in a button:
  /// ```dart
  /// ElevatedButton(
  ///   onPressed: () async {
  ///     await TrustArcConsentImpl.openCm();
  ///   },
  ///   child: Text('Manage My Privacy'),
  /// )
  /// ```
  ///
  /// The SDK must be initialized before calling this method. If not initialized,
  /// this method will return without action.
  ///
  /// @returns Future<void>
  static Future<void> openCm() async {
    if (!_isInitialized) {
      debugPrint('TrustArc: Cannot open CM - SDK not initialized');
      return;
    }

    try {
      debugPrint('TrustArc: Opening Consent Manager');
      await _mobileSdk.openCM();
    } catch (error) {
      debugPrint('TrustArc: Error opening Consent Manager: $error');
      rethrow;
    }
  }

  /// Get current consent status by category
  ///
  /// Retrieves the user's current consent preferences organized by category.
  /// Returns a map where keys are category names and values contain consent details.
  ///
  /// Example usage:
  /// ```dart
  /// final consents = await TrustArcConsentImpl.getConsentStatus();
  /// print('User consents: $consents');
  ///
  /// // Check specific category
  /// if (consents.containsKey('Analytics')) {
  ///   final analyticsConsent = consents['Analytics'];
  ///   print('Analytics consent value: ${analyticsConsent['value']}');
  /// }
  /// ```
  ///
  /// Returns null if SDK is not initialized or if an error occurs.
  ///
  /// @returns Future<Map<String, dynamic>?> Consent data organized by category
  static Future<Map<String, dynamic>?> getConsentStatus() async {
    if (!_isInitialized) {
      debugPrint('TrustArc: Cannot get consent status - SDK not initialized');
      return null;
    }

    try {
      final consentsJson = await _mobileSdk.getConsentDataByCategory();
      final Map<String, dynamic> consents = json.decode(consentsJson);
      return consents;
    } catch (error) {
      debugPrint('TrustArc: Error getting consent status: $error');
      return null;
    }
  }

  /// Check if a specific consent category is granted
  ///
  /// Convenience method to check if the user has granted consent for a specific
  /// category (e.g., "Analytics", "Advertising", "Functional").
  ///
  /// Example usage:
  /// ```dart
  /// final hasAnalyticsConsent = await TrustArcConsentImpl.hasConsent('Analytics');
  /// if (hasAnalyticsConsent) {
  ///   // Initialize analytics tracking
  ///   Analytics.initialize();
  /// }
  /// ```
  ///
  /// @param categoryName Name of the consent category to check
  /// @returns Future<bool> true if consent is granted, false otherwise
  static Future<bool> hasConsent(String categoryName) async {
    final consents = await getConsentStatus();
    if (consents == null || !consents.containsKey(categoryName)) {
      return false;
    }

    final category = consents[categoryName];
    if (category['value'] == "0") {
      // Required category (value 0) is always granted
      return true;
    }

    // Check if any domain has consent value "1" (granted)
    final domains = category['domains'] as List?;
    if (domains == null || domains.isEmpty) {
      return false;
    }

    return domains.any((domain) {
      final values = domain['values'] as List?;
      return values?.contains("1") ?? false;
    });
  }

  // === EVENT LISTENER METHODS ===

  /// Register callback for SDK initialization completion
  ///
  /// The callback will be invoked when the SDK finishes initializing.
  /// This is useful for updating UI state or triggering post-initialization logic.
  ///
  /// Example usage:
  /// ```dart
  /// TrustArcConsentImpl.onSdkInitFinish(() {
  ///   print('SDK is ready!');
  ///   setState(() {
  ///     sdkReady = true;
  ///   });
  /// });
  /// ```
  ///
  /// @param callback Function to call when SDK initialization completes
  static void onSdkInitFinish(Function callback) {
    _onSdkInitFinishCallback = callback;
  }

  /// Register callback for consent changes
  ///
  /// The callback will be invoked whenever the user modifies their consent preferences.
  /// This is the primary way to react to consent changes in your application.
  ///
  /// Example usage:
  /// ```dart
  /// TrustArcConsentImpl.onConsentChange(() async {
  ///   print('User consent preferences changed');
  ///   final hasAnalytics = await TrustArcConsentImpl.hasConsent('Analytics');
  ///   if (hasAnalytics) {
  ///     // Enable analytics
  ///   } else {
  ///     // Disable analytics
  ///   }
  /// });
  /// ```
  ///
  /// @param callback Function to call when consent preferences change
  static void onConsentChange(Function callback) {
    _onConsentChangesCallback = callback;
  }

  /// Register callback for Google consent changes
  ///
  /// The callback will be invoked when Google-specific consent preferences change.
  /// This is useful if your app uses Google services and needs to handle
  /// Google consent separately.
  ///
  /// Example usage:
  /// ```dart
  /// TrustArcConsentImpl.onGoogleConsentChange(() {
  ///   print('Google consent preferences changed');
  ///   // Update Google services configuration
  /// });
  /// ```
  ///
  /// @param callback Function to call when Google consent changes
  static void onGoogleConsentChange(Function callback) {
    _onGoogleConsentChangesCallback = callback;
  }

  // === STATUS QUERY METHODS ===

  /// Check if SDK is currently initialized
  ///
  /// @returns bool true if SDK is initialized and ready to use
  static bool isInitialized() {
    return _isInitialized;
  }

  /// Check if SDK is currently loading
  ///
  /// @returns bool true if SDK initialization is in progress
  static bool isLoading() {
    return _isLoading;
  }

  /// Get the configured domain name
  ///
  /// @returns String TrustArc domain configured for this SDK instance
  static String getDomain() {
    return domain;
  }
}


=== TrustArc CLI Documentation ===
# TrustArc Mobile Consent SDK CLI

A command-line installer for integrating the TrustArc Mobile Consent SDK into your mobile applications.

## Features

- **Automated SDK Integration**: Streamlined installation process for iOS, Android, and React Native projects
- **Multi-Platform Support**:
  - iOS: Swift Package Manager (SPM) & CocoaPods
  - Android: Gradle with version catalog support
  - React Native: Expo & Bare Metal with auto-linking
- **Sample Implementation**: Automatic boilerplate code generation
- **Demo App Downloads**: Pull full sample projects from the private `trustarc/ccm-mobile-consent-test-apps` repository (release branch) for reference
- **AI Assistant (Beta)**: Local AI-powered help for SDK integration
  - Runs completely offline after initial setup
  - Trained on TrustArc SDK documentation and implementation examples
  - PDF documentation indexing support
  - No data sent to external APIs
- **Platform Detection**: Auto-detects your project configuration
- **Git-Safe**: Validates git status before making changes

## Installation

### Method 1: Run from URL (Recommended)

Run the installer directly from GitHub:

```bash
sh -c "$(curl -fsSL https://raw.githubusercontent.com/trustarc-ci/trustarc-cli/refs/heads/main/install.sh)"
```

### Method 2: Run with Cache Bypass

If you need the latest version and want to bypass any caching:

```bash
sh -c "$(curl -fsSL -H 'Cache-Control: no-cache, no-store, must-revalidate' https://raw.githubusercontent.com/trustarc-ci/trustarc-cli/refs/heads/main/install.sh)"
```

### Method 3: Using wget

If you don't have curl installed:

```bash
sh -c "$(wget https://raw.githubusercontent.com/trustarc-ci/trustarc-cli/refs/heads/main/install.sh -O -)"
```

### Method 4: Clone and Run Locally

For development or offline use:

```bash
git clone https://github.com/trustarc-ci/trustarc-cli.git
cd trustarc-cli
./install.sh
```

## Prerequisites

Before running the installer, make sure you have:

- **Operating System**: macOS or Linux
- **Xcode**: Required for iOS integration (macOS only)
- **Git**: Recommended for better change tracking
- **GitHub Token**: Personal Access Token with `repo` and `read:package` scopes
  - Create one at: https://github.com/settings/tokens
  - Required scopes: `repo`, `read:package`
  - Must have access to `trustarc/trustarc-mobile-consent` and `trustarc/ccm-mobile-consent-test-apps`

### CocoaPods Projects (Additional Requirements)

If you're using CocoaPods:
- **CocoaPods**: Install with `sudo gem install cocoapods`
- **Ruby**: CocoaPods requires Ruby (usually pre-installed on macOS)

## What It Does

1. **Authentication**: Securely stores your GitHub token
2. **Platform Detection**: Identifies your project type (iOS, Android, React Native, Flutter)
3. **Dependency Management**: Adds TrustArc SDK to your project
4. **Code Generation**: Creates implementation boilerplate
5. **Verification**: Confirms successful integration

## Platform-Specific Integration

### iOS Integration

The CLI supports:
- Swift Package Manager (SPM)
- CocoaPods
- Swift 5.0+ and iOS 12.0+

**CocoaPods**: Automatically adds the pod with git URL and branch to your Podfile and runs `pod install`
```ruby
pod 'TrustArcConsentSDK', :git => 'https://TOKEN@github.com/...', :branch => 'release'
```

**SPM**: Provides step-by-step instructions for adding the package in Xcode with authentication.

#### Generated Code (iOS)

```swift
// Initialize SDK on app launch
TrustArcConsentImpl.shared.initialize()

// Show consent dialog
TrustArcConsentImpl.shared.openCm()
```

### Android Integration

The CLI supports:
- Gradle (Groovy & Kotlin DSL)
- Version Catalog (libs.versions.toml)
- Android API 28+ (minSdk)
- Kotlin required

**Automatic Configuration**:
- Adds Maven repository to `settings.gradle`
- Configures dependency in `app/build.gradle` or version catalog
- Installs required dependencies (AndroidX, Retrofit, Material)
- Validates AGP-Kotlin compatibility

#### Generated Code (Android)

```kotlin
// Initialize in Application class
TrustArcConsentImpl.initialize(this)

// Show consent dialog
TrustArcConsentImpl.openCm()

// Get consent data
val consents = TrustArcConsentImpl.getConsentData()
```

### React Native Integration

The CLI supports both:
- **Expo (Managed)**: Uses `expo prebuild` to generate native code
- **Bare Metal**: Direct iOS (CocoaPods) and Android (Gradle) integration

**Automatic Detection**:
- Detects project type (Expo vs Bare Metal)
- Identifies package manager (npm/yarn)
- Verifies native module linking

**Expo Flow**:
1. Configures `.npmrc` for GitHub Package Registry authentication
2. Adds `@trustarc/trustarc-react-native-consent-sdk` to package.json
3. Runs `npm install` or `yarn install`
4. Executes `npx expo prebuild` to generate native directories
5. Verifies iOS (Podfile.lock) and Android (build.gradle) integration

**Bare Metal Flow**:
1. Configures `.npmrc` for GitHub Package Registry authentication
2. Adds SDK package to package.json
3. Runs package manager install
4. Executes `pod install` for iOS (if needed)
5. Verifies auto-linking for Android
6. Confirms native modules are properly linked

**`.npmrc` Configuration**:

The CLI automatically creates or updates `.npmrc` with:
```
@trustarc:registry=https://npm.pkg.github.com
//npm.pkg.github.com/:_authToken=${TRUSTARC_TOKEN}
```

This configuration:
- Routes `@trustarc` scoped packages to GitHub Package Registry
- Uses `TRUSTARC_TOKEN` environment variable for authentication
- Preserves existing `.npmrc` settings (appends if file exists)
- Creates backup before modification

#### Generated Code (React Native)

```typescript
// Initialize in App.tsx or _layout.tsx
useEffect(() => {
  TrustArcConsentImpl.initialize();
}, []);

// Show consent dialog
TrustArcConsentImpl.openCm();

// Listen for consent changes
useEffect(() => {
  const unsubscribe = TrustArcConsentImpl.onConsentChange((data) => {
    console.log('Consent changed:', data);
  });
  return unsubscribe;
}, []);

// Get consent data
const consents = await TrustArcConsentImpl.getConsentData();
```

### Integration Steps

1. Choose "Integrate SDK" from the main menu
2. Provide your project path
3. Confirm git status is clean
4. CLI auto-detects platform type
5. Enter your TrustArc domain
6. Follow the guided integration process
7. Optionally generate implementation boilerplate

## AI Assistant (Beta)

The CLI includes a local AI assistant to help with SDK integration questions. It runs completely offline after initial setup and doesn't send any data to external APIs.

### First-Time Setup

When you first select "AI Assistant" from the main menu:

1. The CLI will ask to download required components (~700MB one-time download):
   - llama.cpp inference engine (~10MB)
   - DeepSeek-Coder 1.3B model (~700MB)
   - Pre-built knowledge base trained on TrustArc SDK documentation
2. Files are stored in `~/.trustarc-cli/ai/` for reuse
3. Setup is automatic - just confirm the download

### Features

**Chat Mode**: Ask questions about SDK integration
```
You: How do I initialize the SDK in Swift?
AI: To initialize the TrustArc SDK in Swift, call TrustArcConsentImpl.shared.initialize()
    in your AppDelegate's didFinishLaunchingWithOptions method...
```

**Pre-Trained Knowledge Base**: Includes
- iOS Swift implementation examples
- Android Kotlin implementation examples
- React Native TypeScript implementation
- Flutter Dart implementation
- Common troubleshooting and FAQ
- Platform-specific integration guides

**Simple Menu**:
1. Chat with AI Assistant
2. View AI status (downloads, disk usage)
3. Back to main menu

### Requirements

- **macOS**: Apple Silicon (arm64) or Intel (x64)
- **Linux**: x64 architecture
- **Disk Space**: ~1GB for AI files

### Performance

- First response: ~2-5 seconds (model loading)
- Subsequent responses: ~1-3 seconds
- Runs on CPU (no GPU required)

### Privacy

- Everything runs locally on your machine
- No data is sent to external servers
- Knowledge base stays on your computer
- Safe for proprietary projects

### Limitations

- Responses may not be 100% accurate (beta feature)
- Best for general SDK questions and code examples
- For complex issues, consult official documentation
- Knowledge base is maintained by TrustArc and cannot be customized by end users

## Configuration

The CLI stores configuration in two places:

### 1. Shell Configuration File
Your GitHub token is saved to your shell configuration file:
- **zsh**: `~/.zshrc`
- **bash**: `~/.bashrc` or `~/.bash_profile`
- **fish**: `~/.config/fish/config.fish`

The token is exported as `TRUSTARC_TOKEN` environment variable.

### 2. CLI Configuration File
Project preferences are stored in `~/.trustarc-cli-config`:
- Last used domain
- Platform preferences
- Other settings

## Cleanup

To remove all CLI configuration and tokens:

1. Run the installer again:
   ```bash
   sh -c "$(curl -fsSL https://raw.githubusercontent.com/trustarc-ci/trustarc-cli/refs/heads/main/install.sh)"
   ```

2. Select option **3) Clean up (remove token and config)**

3. Restart your terminal for changes to take effect

This will:
- Remove `TRUSTARC_TOKEN` from your shell configuration
- Delete `~/.trustarc-cli-config`
- Remove AI Assistant files and models (`~/.trustarc-cli/ai/`)
- Create a backup of your shell config

## Troubleshooting

### "Token validation failed"
- Verify your token has `repo` and `read:package` scopes
- Ensure the token has access to `trustarc/trustarc-mobile-consent` repository
- Try regenerating your GitHub token

### "Could not detect platform type"
- Make sure you're in a valid iOS project directory
- Look for `.xcodeproj`, `.xcworkspace`, or `Podfile` files

### "You have uncommitted changes"
- Commit or stash your changes before running integration
- Use `git status` to see uncommitted files
- Run `git commit` or `git stash`

### "Package does not appear in project.pbxproj" (SPM)
- Close and reopen Xcode
- Clean build folder (Cmd+Shift+K)
- Verify the package appears in Package Dependencies tab

### "pod install failed" (CocoaPods)
- Verify the podspec exists in the repository
- Check that CocoaPods is installed: `pod --version`
- Try running `pod repo update`

### "Unable to resolve @trustarc/trustarc-react-native-consent-sdk" (React Native)
- Check that `.npmrc` exists in your project root
- Verify `.npmrc` contains the GitHub registry configuration:
  ```
  @trustarc:registry=https://npm.pkg.github.com
  //npm.pkg.github.com/:_authToken=${TRUSTARC_TOKEN}
  ```
- Ensure `TRUSTARC_TOKEN` environment variable is set:
  ```bash
  echo $TRUSTARC_TOKEN  # Should output your token
  ```
- Restart your terminal after setting the token
- Try clearing npm cache: `npm cache clean --force`
- For yarn: `yarn cache clean`

### "TrustArcMobileSdk native module not found" (React Native)
- Ensure you ran `npm install` or `yarn install` after adding the package
- For Expo: Run `npx expo prebuild` to generate native directories
- For Bare Metal iOS: Run `cd ios && pod install`
- For Bare Metal Android: Clean and rebuild with `cd android && ./gradlew clean`
- Restart Metro bundler: `npx react-native start --reset-cache`

### "Prebuild failed" (Expo)
- Check that all dependencies are properly installed
- Verify `app.json` has correct configuration
- Try removing `ios/` and `android/` directories and running prebuild again
- Check Expo CLI version: `npx expo --version`

### "Auto-linking not working" (React Native Bare Metal)
- Verify `use_native_modules!` is in your iOS Podfile
- Check `applyNativeModulesSettingsGradle` is in Android settings.gradle
- Clean both platforms:
  - iOS: `cd ios && pod deintegrate && pod install`
  - Android: `cd android && ./gradlew clean`

### Getting the latest version
Use the cache-bypass command:
```bash
sh -c "$(curl -fsSL -H 'Cache-Control: no-cache, no-store, must-revalidate' https://raw.githubusercontent.com/trustarc-ci/trustarc-cli/refs/heads/main/install.sh)"
```

## Support

For issues or questions, please visit:
- [TrustArc Documentation](https://docs.trustarc.com)
- [GitHub Issues](https://github.com/trustarc-ci/trustarc-cli/issues)

## License

Copyright  2024 TrustArc. All rights reserved.


=== PDF: MAC-3.1-draft.pdf ===
Mobile App Consent
Integration Guide

CONFIDENTIAL AND PROPRIETARY

Revision History
Document Version

Date

Description

2.9

05-08-2025

Updated for the dependency management
migration

Current SDK Version: 2025.04.2

3.0

07-03-2025

Updated sample implementations to add the
getConsentDataByCategory() and the
enableAppTrackingTransparencyPrompt()

functions
3.1

09-23-2025

Updated sections for IAB Transparency &
Consent Framework (TCF 2.2) and API
References for Google-certified App
Attribution Partners for Appflyers, AirBridge,
Singular and Firebase

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

2

About This Document
This document outlines the steps on how to integrate the TrustArc Mobile Consent SDK into your mobile
app and provide transparency into the third-party technologies responsible for collecting and sharing
user data.

Target Audience
This document is intended for web developers, programmers, back-end servers, or trusted parties
performing administrative tasks.

Disclaimer
Information in this document is subject to change without notice. No part of this document may be
reproduced or transmitted in any form by any means, electronic or mechanical, for any purpose, without
the express written permission of TrustArc Inc. Moreover, this guide is strictly informational in nature and
is not intended to provide legal advice, as all legal and compliance obligations and interpretations
remain the responsibility of users in coordination with their legal counsel.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

3

Table of Contents
Overview
Platforms
Android
Requirements
Before You Begin
Getting Started
Sample Implementation/Usage
Migration Guides
iOS
Requirements
Before You Begin
Getting Started
Sample Implementation / Usage
Migration Guides
React Native
Requirements
Before You Begin
Getting Started
Sample Implementation / Usage
Migration Guides
Flutter
Requirements
Before You Begin
Getting Started
Sample Implementation / Usage
Migration Guides
IAB Transparency & Consent Framework (TCF 2.2)
Android
iOS
React Native
Flutter
App Attribution Partner (AAP) Plugins
Overview
Platform Implementation Guides
Android Implementation
API References
US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

6
6
6
6
7
7
9
16
18
18
18
18
22
36
40
40
40
40
46
52
57
57
57
57
60
67
68
68
70
72
72
74
74
74
74
86
4

Android
Core Classes
TrustArc Class
TrustArcVendorConsentViewModel
TASharedInstance
VendorConsent
IABTCFPreferences
iOS
TrustArc Class
TADelegate Protocol
TAConsentViewControllerDelegate Protocol
TAGoogleConsentsDelegate Protocol
TAConsentReporterDelegate Protocol
IABTCFPreferences
React Native
TrustArc Class
VendorConsent Object
SdkMode Enum
IABTCFPreferences
Flutter
FlutterTrustarcMobileConsentSdk Class
Behavior and User Experience
Troubleshooting
SDK Integration Issue
Resolution

86
86
86
90
90
90
91
92
92
94
95
95
97
97
99
99
101
101
102
104
104
110
112
112
112

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

5

Overview
TrustArc, the market leader in comprehensive privacy and compliance solutions, has created the
TrustArc Mobile App Consent to help companies develop mobile solutions that make their products
privacy-friendly and compliant while providing consumers with transparency and control over the
collection and use of their data across mobile applications.
The TrustArc Mobile App Consent solution is designed to manage user consent and provide
transparency into the third-party technologies responsible for collecting and sharing user data. This
solution simplifies mobile compliance efforts with the integration of an SDK.

Platforms
Android
The TrustArc Mobile Consent SDK for Android simplifies privacy compliance integration in your mobile
applications. This SDK provides transparency into third-party technologies integrated within your app
that collect and share user data.
The SDK enables:
 User consent collection and management
 Streamlined consent manager implementation in Android applications
 Opt-in and opt-out analytics tracking
 Seamless connection with TrustArc's privacy management ecosystem
This guide will walk you through implementing the TrustArc Mobile Consent SDK in your Android
application.

Requirements
 Android Studio 2023.2.1 or higher (or any preferred IDE tool)
 Minimum Android SDK 29

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

6

Before You Begin
To get started, contact the TrustArc Support team at support@trustarc.com to request access tokens for
downloading the SDKs from the GitHub repository. These SDKs will be integrated into your project via
your dependency manager. Your designated TrustArc Technical Account Manager (TAM) will guide you
through the onboarding process, assist with project setup, and provide support for any technical issues
that may arise.
Important: Access tokens remain valid until the renewal of your contract. Once your contract is
renewed, you will need to request a new token to continue accessing the SDKs.
NOTE: The list of trackers obtained from the scanned results of your application to be included here will
be provided separately.

Getting Started
To integrate the Android SDK to your app, follow the steps outlined below.
1. Add the TrustArc Maven repository to either your project's build.gradle repositories section or

settings.gradle dependencyResolutionManagement section, depending on which file your project
uses for dependency management.
NOTE: The GitHub access token required for authentication will be provided by your
representative from the TrustArc support team at support@trustarc.com. Make sure to keep this
token secured and do not expose it in version control.
None
repositories {
google()
mavenCentral()
maven {
name = "TrustArcMobileConsent"
url = uri("https://maven.pkg.github.com/trustarc/trustarc-mobile-consent")
credentials {
username = "trustarc"
password = "<Paste Your Token Here>"
}
}
}

2. Add the SDK dependency to your app modules build.gradle:

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

7

None
dependencies {
// You can use "+" to always use the latest release
implementation("com.trustarc:trustarc-consent-sdk:2025.04.2")
// Required dependencies
implementation("androidx.core:core-ktx:1.9.0")
implementation("androidx.appcompat:appcompat:1.6.1")
implementation("androidx.constraintlayout:constraintlayout:2.1.4")
implementation("androidx.webkit:webkit:1.4.0")
implementation("androidx.lifecycle:lifecycle-extensions:2.2.0")
implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.2")
implementation("androidx.activity:activity:1.8.0")
implementation("com.google.android.material:material:1.9.0")
implementation("com.squareup.retrofit2:retrofit:2.9.0")
implementation("com.squareup.retrofit2:converter-gson:2.9.0")
}

3. In your Activity, use the SDK as follows:
None
// Set up TrustArc SDK
trustArcSDK = TrustArc(
context = applicationContext,
sdkMode = SdkMode.Standard,
onGoogleConsent = {
handleGoogleConsents(this)
})
// Begin domain configuration retrieval
// Note: consent modal will automatically appear in "expressed" mode
trustArcSDK.start(
domainName = "mac_trustarc.com",
onConsent = {
handleConsentChanges()
})

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

8

Sample Implementation/Usage
Listening and honoring user consents
NOTE: The TrustArc SDK returns consent values as "1" (consented) or "0" (rejected) for each vendor
domain.
In cases where a domain serves multiple purposes across different categories, a numerical suffix is
added to distinguish them:
 sample.com (first occurrence - no suffix needed)
 sample.com-0 (required - when duplicate)
 sample.com-1 (functional - when duplicate)
 sample.com-2 (advertising - when duplicate)
 sample.com-3 (custom - when duplicate)
For example, if "consents.trustarc.com" appears in both functional and advertising categories, the
second instance will be labeled as "consents.trustarc.com-2" to identify its advertising purpose.

Option 1: Sample implementation using the onConsent callback
Kotlin
None
fun handleConsentChanges() {
// Getting consent data from storage
val vendorConsents: List<VendorConsent> = trustArcSDK.getStoredConsentData()
val consentedDomains = mutableListOf<String>()
val nonConsentedDomains = mutableListOf<String>()
for (consent in vendorConsents) {
val domain = consent.domain
// Extract base domain if it has a category suffix
val baseDomain = if (domain.matches(Regex(".+-(0|1|2|3)$"))) {
domain.replace(Regex("-(0|1|2|3)$"), "")
} else {
domain
}
// Sort by consent status
if (consent.consent == "1") {
consentedDomains.add(baseDomain)
} else {
nonConsentedDomains.add(baseDomain)
}

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

9

// Handle domains by category
when {
domain.endsWith("-0") -> { /* Required category handling */ }
domain.endsWith("-1") -> { /* Functional category handling */ }
domain.endsWith("-2") -> { /* Advertising category handling */ }
domain.endsWith("-3") -> { /* Custom category handling */ }
}
}
// Apply tracking settings based on consent status
Log.d("TrustArc", "Consented domains: $consentedDomains")
Log.d("TrustArc", "Non-consented domains: $nonConsentedDomains")
}
fun initializeTrustArcSdk() {
// ... rest of the implementation
// Initialize SDK parameters, configuration, etc.
trustArcSDK.start(
domainName = domain,
ipAddress = ipAddress,
language = locale,
onConsent = {
handleConsentChanges()
},
onInitFinish = { /* SDK initialization complete */ }
)
}

Option 2: Sample implementation using the TrustArcVendorConsentModel
Kotlin
None
class MainActivity : ComponentActivity() {
private lateinit var trustArcSDK: TrustArc
private lateinit var vendorConsentModel: TrustArcVendorConsentModel
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
// ... rest of the implementation
// Initialize vendor consent view model
vendorConsentModel =
ViewModelProvider.create(this)[TrustArcVendorConsentViewModel::class.java]

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

10

vendorConsentModel.getVendorConsents().observe(this, Observer {
it.forEach {
Log.d("Consent", "${it.domain} : ${it.consent}")
}
})
}
override fun onResume() {
super.onResume()
if (trustArcSDK.isConsentPresent()) {
vendorConsentModel.loadVendorConsents()
}
}
}

Starting with release version 2025.07.1, a new SDK function called getConsentsByCategory() has
been introduced. This function groups tracker domains by category, making it easier for developers to
retrieve consents and ensuring that the appropriate consents are correctly applied to each category.
Furthermore, domain consent values are represented by the following:
2 - Domains listed in the Required Category bucket that are always consented since they are essential
1 - Consented domains where users have granted permission
0 - Non-consented domains where users have denied or not granted permission

Kotlin
Java
private fun handleConsentChanges() {
// Getting consent data by category
val consentMap: Map<String, TAConsent> = trustArc.getConsentDataByCategory()
// Maps to store consented and non-consented domains for each category
val consentedDomainsByCategory = mutableMapOf<String, MutableList<String>>()
val nonConsentedDomainsByCategory = mutableMapOf<String, MutableList<String>>()
consentMap.entries.forEach { entry ->
val categoryName = entry.key
val consent = entry.value
val categoryValue = consent.value
// Initialize lists for this category if not exists
consentedDomainsByCategory[categoryName] = mutableListOf()

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

11

nonConsentedDomainsByCategory[categoryName] = mutableListOf()
// Process domains for this category
consent.domains?.forEach { domainEntry ->
domainEntry.entries.forEach { (domain, consentValue) ->
if (consentValue != "0") {
consentedDomainsByCategory[categoryName]!!.add(domain)
} else {
nonConsentedDomainsByCategory[categoryName]!!.add(domain)
}
}
}
}
// Apply tracking settings based on consent status per category
consentedDomainsByCategory.forEach { (category, domains) ->
Log.d("TrustArc", "Category '$category' - Consented domains: $domains")
}
nonConsentedDomainsByCategory.forEach { (category, domains) ->
Log.d("TrustArc", "Category '$category' - Non-consented domains: $domains")
}
}

Google Consent Mode
Google Consent Mode allows websites to adjust Google tags based on user consent status. The TrustArc
SDK provides the Consent UI and supports these consent options:
 ads_storage: Enables advertising cookies
 analytics_storage: Enables analytics cookies
 ad_personalization: Controls data use for ad personalization
 ad_user_data: Controls personal data sharing with Google services
Prerequisite: Contact your TrustArc Technical Account Manager to ensure consent mode tags are
properly mapped.
For integration details:
https://developers.google.com/tag-platform/security/guides/app-consent?platform=android
The following steps needs to be done from the application side:
1. Add Firebase SDK to your application following this guide:
US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

12

https://firebase.google.com/docs/android/setup. You need to add google-services.json to your
project and set up the google services plugin.
2. Add Firebase Analytics dependencies to your project Gradle.
None
dependencies {
implementation(platform("com.google.firebase:firebase-bom:32.7.0"))
implementation("com.google.firebase:firebase-analytics")
}

3. Configure default consent settings in AndroidManifest.xml. Typically, set all consent options to
"denied" by default.
None
<application
...>
<meta-data
android:name="google_analytics_default_allow_analytics_storage"
android:value="false" />
<meta-data
android:name="google_analytics_default_allow_ad_storage"
android:value="false" />
<meta-data
android:name="google_analytics_default_allow_ad_user_data"
android:value="false" />
<meta-data
android:name="google_analytics_default_allow_ad_personalization_signals"
android:value="false" />
</application>

4. Initialize TrustArc SDK with onGoogleConsent callback. You must implement logic to send consent
choices collected by the TrustArc SDK Consent UI to Firebase Analytics.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

13

Kotlin
None
private fun handleGoogleConsents(googleConsentsScope: GoogleConsentsScope) {
Firebase.analytics.setConsent {
googleConsentsScope.grantedAdStorage?.let { adStorage =
if (it) ConsentStatus.GRANTED else ConsentStatus.DENIED }
googleConsentsScope.grantedAnalyticsStorage?.let { analyticsStorage =
if (it) ConsentStatus.GRANTED else ConsentStatus.DENIED }
googleConsentsScope.grantedAdUserData?.let { adUserData =
if (it) ConsentStatus.GRANTED else ConsentStatus.DENIED }
googleConsentsScope.grantedAdPersonalization?.let { adPersonalization =
if (it) ConsentStatus.GRANTED else ConsentStatus.DENIED }
}
}
fun initializeTrustArcSdk() {
trustArcSDK = TrustArc(
context = applicationContext,
sdkMode = if(isIab) SdkMode.IabTCFv_2_2 else SdkMode.Standard,
onGoogleConsent = {
handleGoogleConsents(this)
})
// ... rest of the implementation
}

For debugging purposes you can enable Firebase Logging via the series of the adb commands:
None
adb shell setprop log.tag.FA VERBOSE
adb shell setprop log.tag.FA-SVC VERBOSE
adb logcat -v time -s FA FA-SVC

Check logcat for "Setting consent" messages and use Firebase Debug View for real-time troubleshooting
(enable with adb shell setprop debug.firebase.analytics.app <PACKAGE_NAME>).

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

14

Web Consent Manager Integration
If you have an existing consent manager on your website and wish to integrate it with your mobile app,
you can do so by enabling mobile app consent-to-web integration. Please contact your designated
TrustArc Technical Account Manager to enable this feature.
Once the integration is enabled, follow these steps to configure it on your app:
1. Create a webview implementation on your mobile app. Override onPageCommitVisible and get
the script from Trustarc.getWebScript().
Kotlin
Java
val webView: WebView = findViewById(R.id.webview)
val trustarc: TrustArc = TrustArc(applicationContext)
webView.webViewClient = object : WebViewClient() {
override fun onPageCommitVisible(view: WebView?, url: String?) {
webView.evaluateJavascript(javaScript) { javaScriptResult ->
Log.d("CONSENT SCRIPT","Loaded script: $javaScriptResult")
}
}

Java
Java
WebView webView = (WebView) findViewById(R.id.webview);
Trustarc trustarc = new TrustArc(getApplicationContext());
webView.setWebViewClient(new WebViewClient() {
@Override
public boolean onPageCommitVisible(WebView view, String url) {
webview.evaluateJavascript(trustarc.getWebScript(), new
ValueCallback<String>() {
@Override
public void onReceiveValue(String value) {value ->
Log.d("CONSENT SCRIPT","loaded script")}
}
});
}
});

2. To confirm that the integration is complete, use chrome://inspect to view the WebView's cookie
storage.
US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

15

NOTE: Mobile Consent UI will display a combined category and tracker list from both the domain
and web domain.

Migration Guides
From Local .AAR Library to GitHub Packages
Follow these steps to migrate from using the local .AAR file to using GitHub Packages as your
dependency source:
NOTE: This migration process is applicable for SDK versions before the 2025.04.2 release.
1. Add the TrustArc Maven repository to either your project's build.gradle repositories section or
settings.gradle dependencyResolutionManagement section, depending on which file your project
uses for dependency management.
NOTE: The GitHub access token required for authentication will be provided by your
representative from the TrustArc support team at support@trustarc.com. Make sure to secure this
token and do not expose it in version control.
None
repositories {
google()
mavenCentral()
maven {
name = "TrustArcMobileConsent"
url = uri("https://maven.pkg.github.com/trustarc/trustarc-mobile-consent")

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

16

credentials {
username = "trustarc"
password = "<Paste Your Token Here>"
}
}
}

2. Replace the local .AAR file reference with the Maven dependency by changing
implementation(fileTree("libs") { include("*.aar", "*.jar") }) to
implementation("com.trustarc:trustarc-consent-sdk:2025.04.2") while keeping all other
existing dependencies intact.
Java
dependencies {
implementation(fileTree("libs") { include("*.aar", "*.jar") })
+
implementation("com.trustarc:trustarc-consent-sdk:2025.04.2")
// Keep the existing dependencies
implementation("androidx.core:core-ktx:1.9.0")
// ... other dependencies remain the same
}

3. Remove the local .AAR file from your project's app/libs directory:
None
rm -f app/libs/trustarc-consent-sdk-*.aar

4. Run Gradle clean and sync.
None
./gradlew clean

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

17

iOS
The TrustArc Mobile Consent SDK for iOS simplifies privacy compliance integration in your mobile
applications. This SDK provides transparency regarding third-party technologies that collect and share
user data. The SDK enables:
 User consent collection and management
 Streamlined consent manager implementation in iOS applications
 Opt-in and opt-out analytics tracking
 Seamless connection with TrustArc's privacy management ecosystem This guide will walk you
through implementing the TrustArc Mobile Consent SDK in your iOS application.

Requirements
 Xcode 16 or later
 iOS 12 or later
 Swift 6 or later (source-compatible with Swift 5)

Before You Begin
For more information on how to get started, refer to the instructions here.

Getting Started
To integrate the iOS SDK to your app, follow the steps outlined below.
1. In Xcode, go to File > Add Package Dependencies
2. Click on the + button from the bottom left of the Apple Swift Packages screen and click Add
Source Control Account.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

18

3. Select Github, then input trustarc for username, and the access token provided by your
representative from the TrustArc support team for the password, then click Sign In.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

19

4. Go back to the Apple Swift Packages screen, enter
https://github.com/trustarc/trustarc-mobile-consent.git in the search bar, and press
Enter.

5. Enter release as the branch name or specify a version tag like "v2025.04.02", then click Add
Package.
6. Choose your target application and click Add Package.

7. Click on your project, then navigate to Package Dependencies. You should now be able to see
TrustArcConsentSDK listed among your Package Dependencies.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

20

8. To verify the authenticity of the provided SDK, please check the signature in Xcode by navigating
to Package Dependencies > ios > trustarc_consent_sdk. The signature should resemble the
example shown below.

9. In your ViewController, import and initialize the SDK:

Swift
None
// When using Swift 6, you must apply the @MainActor attribute to any classes that
// interact with the TrustArc SDK or perform UI operations, as Swift 6 enforces strict
// concurrency rules.
@MainActor
func loadTrustArcSdk() {
// Set delegates to handle closing of webview
TrustArc.sharedInstance.delegate = self
TrustArc.sharedInstance.controller.delegate = self
// Initialize TrustArc SDK with domain and sdk mode
_ = TrustArc.sharedInstance.setDomain("mac_trustarc.com")
_ = TrustArc.sharedInstance.setMode(.standard)
// Start SDK
TrustArc.sharedInstance.start { shouldShowConsentUI in
Task { @MainActor in
if shouldShowConsentUI {
self.requestTrackingPermission()
} else {
print("Do nothing")
}
}
}
}

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

21

Sample Implementation / Usage
Listening and honoring user consents
NOTE: The TrustArc SDK returns consent values as "1" (consented) or "0" (rejected) for each vendor
domain.
In cases where a domain serves multiple purposes across different categories, a numerical suffix is
added to distinguish them:
 sample.com (first occurrence - no suffix needed)
 sample.com-0 (required - when duplicate)
 sample.com-1 (functional - when duplicate)
 sample.com-2 (advertising - when duplicate)
 sample.com-3 (custom - when duplicate)
For example, if "consents.trustarc.com" appears in both functional and advertising categories, the
second instance would be labeled "consents.trustarc.com-2" to identify its advertising purpose.
To listen for consent updates, you need to implement didReceiveConsentData from the
TAConsentViewControllerDelegate protocol:
None
@MainActor
func consentViewController(_ consentViewController:
trustarc_consent_sdk.TAConsentViewController, didReceiveConsentData consentData:
[String : Any]) {
consentViewController.dismiss(animated: true) {
var consentedDomains = [String]()
var nonConsentedDomains = [String]()
for consent in consentData {
let domain = consent.key
// Extract base domain if it has a category suffix
let baseDomain: String
if domain.range(of: ".+-(0|1|2|3)$", options: .regularExpression) != nil {
baseDomain = domain.replacingOccurrences(of: "-(0|1|2|3)$", with: "",
options: .regularExpression)
} else {
baseDomain = domain
}
// Sort by consent status

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

22

if consent.value as! String == "1" {
consentedDomains.append(baseDomain)
} else {
nonConsentedDomains.append(baseDomain)
}
// Handle domains by category
if domain.hasSuffix("-0") {
/* Required category handling */
} else if domain.hasSuffix("-1") {
/* Functional category handling */
} else if domain.hasSuffix("-2") {
/* Advertising category handling */
} else if domain.hasSuffix("-3") {
/* Custom category handling */
}
}
// Apply tracking settings based on consent status
print("TrustArc: Consented domains: \(consentedDomains)")
print("TrustArc: Non-consented domains: \(nonConsentedDomains)")
}
}

Starting with release version 2025.07.1, a new SDK function called getConsentsByCategory() has
been introduced. This function groups tracker domains by category, making it easier for developers to
retrieve consents and ensuring that the appropriate consents are correctly applied to each category.
Furthermore, domain consent values are represented by the following:
2 - Domains listed in the Required Category bucket that are always consented since they are essential
1 - Consented domains where users have granted permission
0 - Non-consented domains where users have denied or not granted permission
C/C++
private func handleConsentChanges() {
// Getting consent data by category
let consentMap = TrustArc.sharedInstance.getConsentDataByCategory()
// Dictionaries to store consented and non-consented domains for each category
var consentedDomainsByCategory: [String: [String]] = [:]
var nonConsentedDomainsByCategory: [String: [String]] = [:]

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

23

for (categoryName, consent) in consentMap {
// Initialize arrays for this category if not exists
consentedDomainsByCategory[categoryName] = []
nonConsentedDomainsByCategory[categoryName] = []
// Process domains for this category
if let domains = consent.domains {
for domainEntry in domains {
for (domain, consentValue) in domainEntry {
if consentValue != "0" {
consentedDomainsByCategory[categoryName]?.append(domain)
} else {
nonConsentedDomainsByCategory[categoryName]?.append(domain)
}
}
}
}
}
// Apply tracking settings based on consent status per category
for (category, domains) in consentedDomainsByCategory {
print("Category '\(category)' - Consented domains: \(domains)")
}
for (category, domains) in nonConsentedDomainsByCategory {
print("Category '\(category)' - Non-consented domains: \(domains)")
}
}

ATT Enabled Mobile CM Behavior on iOS SDK
Whenever a newly installed app is opened for the first time, iOS shows a pop-up message that prompts
the user to allow or not allow App Tracking. This is the default behavior.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

24

If users selected the Ask App Not to Track option, the SDK automatically opts in the required cookies
only.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

25

If users prefer to change their consent preferences while ATT is disabled on the mobile device, they will
encounter an Opt-out window. Selecting the Close button, only dismisses the Consent Preference
window.
If the user changes the setting to allow the app after the initial app load, the consent preference data will
still persist. However, if users change their consent preferences, the usual mobile consent will display
and will go through the usual configurations.
If the user allows app tracking on initial app load, they will go through the usual consent preference
configuration process where they can choose to Accept All, Decline All, or customize their
preferences by consent categories.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

26

The following instructions will guide you through the process of integrating App Tracking Transparency
(ATT) with the iOS SDK.
1. Insert NSUserTrackingUsageDescription to info.plist and add any String desired that
expresses how trackers will be used in general.




NOTE: The key changes to Privacy - Tracking Usage Description when you press Enter.
2. Import the AppTrackingTransparency framework in the ViewController of the application.

Swift
None
import SwiftUI
import AppTrackingTransparency
import os.log
import trustarc_consent_sdk
import WebKit
// .. rest of the code

Objective-C
None
#import "ViewController.h"
#import <AppTrackingTransparency/AppTrackingTransparency.h>
#import "trustarc_consent_sdk/trustarc_consent_sdk.h"

3. Create a function to manage App Tracking Transparency permissions. When the user grants
tracking authorization, setIsTrackingEnabled is set to True and openCM is invoked afterwards.
When the user denies permission or has restricted status, confirmRequiredTrackers is invoked to
consent only to required trackers.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

27

NOTE: The confirmRequiredTrackers function opens a webView instance in the background,
which is why TAConsentViewControllerDelegate is passed to handle the resulting consent data.

Swift
None
@MainActor
func requestTrackingPermission() {
guard #available(iOS 14, *) else {
print("Tracking not available")
return
}
Task {
let status = await ATTrackingManager.requestTrackingAuthorization()
switch status {
case .authorized:
self.attStatusString = "authorized"
if let rootView = self.getRootView() {
_ = TrustArc.sharedInstance.setIsTrackingEnabled(true)
TrustArc.sharedInstance.openCM(in: rootView, delegate: self)
}
case .notDetermined:
self.requestTrackingPermission()
default:
self.attStatusString = "non authorized"
if let rootView = self.getRootView() {
// If non authorized ATT, then just confirm trackers
// without opening modal
TrustArc.sharedInstance.confirmRequiredTrackers(in: rootView, delegate:
self)
}
}
}
}
@MainActor
func loadTrustArcSdk() {
// .. omitted code for brevety
// IF shouldShowConsentUI is true, then we have to request ATT value
// ELSE just do nothing
TrustArc.sharedInstance.start { shouldShowConsentUI in
Task { @MainActor in
if shouldShowConsentUI {
self.requestTrackingPermission()
} else {
print("Do nothing")
}
}

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

28

}
}

Objective-C
None
- (void) showATTPopup {
if (@available(iOS 14, *)) {
[ATTrackingManager
requestTrackingAuthorizationWithCompletionHandler:^(ATTrackingManagerAuthorizationStat
us status) {
dispatch_async(dispatch_get_main_queue(), ^{
switch (status) {
case ATTrackingManagerAuthorizationStatusAuthorized:
NSLog(@"authorized");
// MARK: If Authorized, we have to check if consent is already present,
// if not, then show consent modal
// No need to open modal if consent is already present
if(![[TrustArc sharedInstance] isConsentPresent]) {
[[TrustArc sharedInstance] setIsTrackingEnabled: true];
[[TrustArc sharedInstance] openCMIn:self delegate:self];
}
break;
case ATTrackingManagerAuthorizationStatusNotDetermined:
// If not determined, so we should re-run this function
// to request ATT once more
NSLog(@"not determined");
[self showATTPopup];
break;
default:
// If ATT status is declined, restricted, or unknown,
// then we default to tracker denied
if(![[TrustArc sharedInstance] isConsentPresent]) {
NSLog(@"Tracking denied, confirming required trackers determined");
[[TrustArc sharedInstance] confirmRequiredTrackersIn:self
delegate:self];
}
break;
}
});
}];
} else {
// Fallback for iOS versions prior to 14
NSLog(@"App Tracking Transparency not available");
}
}

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

29

- (void) loadTrustArcSdk {
// .. omitted code for brevety
// IF shouldShowConsentUI is true, then we have to request ATT value
// ELSE just do nothing
[[TrustArc sharedInstance] startWithCompletion:^(BOOL shouldShowConsentUI) {
if(shouldShowConsentUI) {
dispatch_async(dispatch_get_main_queue(), ^{
[self showATTPopup];
});
} else {
NSLog(@"Do nothing");
}
}];
}

Starting with version 2025.07.1, the iOS SDK simplifies App Tracking Transparency (ATT) integration by
providing the enableAppTrackingTransparencyPrompt() function with a single configuration flag to
enable or disable the system-level ATT prompt. By default, this function is disabled. To enable it, use the
following code implementation:
None
TrustArc.sharedInstance
.enableAppTrackingTransparencyPrompt(true)
.start { shouldShowConsentUI in
if #available(iOS 13.0, *) {
Task { @MainActor in
if shouldShowConsentUI {
TrustArc.sharedInstance.openCM(in: self, delegate: self)
} else {
print("Repop will not show consent UI, so do nothing")
}
}
}
}

When shouldShowConsentUI is true, the application should call openCM() to display the consent
management modal. This step is intentionally not handled automatically by the SDK, giving developers
the flexibility to add custom logic after the ATT prompt is shown, such as additional analytics tracking,
custom UI preparations, or other business-specific operations before presenting the consent interface.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

30

Google Consent Mode
Google Consent Mode allows websites to adjust Google tags based on user consent status. The TrustArc
SDK provides the Consent UI and supports these consent options:
 ads_storage: Enables advertising cookies
 analytics_storage: Enables analytics cookies
 ad_personalization: Controls data use for ad personalization
 ad_user_data: Controls personal data sharing with Google services
Prerequisite: Contact your TrustArc Technical Account Manager to ensure consent mode tags are
properly mapped.
For integration details:
https://developers.google.com/tag-platform/security/guides/app-consent?platform=ios
The following steps needs to be done from the application side:
1. Add Firebase SDK to your application following this guide
https://firebase.google.com/docs/ios/setup. You need to add GoogleServices-Info.plist to
your project and add Firebase SDK via Swift Package Manager or Cocoapods.
2. Add Firebase Analytics dependencies to your project following
https://firebase.google.com/docs/analytics/get-started?platform=ios.
3. Initialize Firebase services in your app delegates
application(_:didFinishLaunchingWithOptions:) method.
None
func application(_ application: UIApplication, didFinishLaunchingWithOptions
launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
FirebaseApp.configure()
return true
}

4. Setup default consent for your application in Info.plist. Typically, set all consent options to
"denied" by default.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

31

None
<key>GOOGLE_ANALYTICS_DEFAULT_ALLOW_ANALYTICS_STORAGE</key>
<false/>
<key>GOOGLE_ANALYTICS_DEFAULT_ALLOW_AD_STORAGE</key>
<false/>
<key>GOOGLE_ANALYTICS_DEFAULT_ALLOW_AD_USER_DATA</key>
<false/>
<key>GOOGLE_ANALYTICS_DEFAULT_ALLOW_AD_PERSONALIZATION_SIGNALS</key>
<false/>

5. Implement TrustArc SDK initialization with Google Consent Delegate, including logic to transfer
consent preferences from the TrustArc SDK Consent UI to Firebase Analytics.
None
TrustArc.sharedInstance
.setMode(.standard)
.setDomain("mac_trustarc.com")
.setGoogleConsentDelegate(self)
.start { shouldShowConsentUI in
// ...rest of code
}

None
extension ViewController: TAGoogleConsentsDelegate {
func didUpdateConsentData(grantedAdStorage: Bool, grantedAnalyticsStorage: Bool,
grantedAdUserData: Bool, grantedAdPersonalization: Bool) {
Analytics.setConsent([
.adStorage: grantedAdStorage ? .granted : .denied,
.analyticsStorage: grantedAnalyticsStorage ? .granted : .denied,
.adUserData: grantedAdUserData ? .granted : .denied,
.adPersonalization: grantedAdPersonalization ? .granted : .denied
])
}
}

6. For the debugging purposes, you can enable verbose logging to monitor logging of events by the
SDK to help verify that events are being logged properly.
a. In Xcode, select Product > Scheme > Edit scheme
b. Select Run from the left menu.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

32

c. Select the Arguments tab.
d. In the Arguments Passed On Launch section, add
-FIRAnalyticsVerboseLoggingEnabled.
e. Restart the app and look for ad_storage, analytics_storage, ad_user_data,
ad_personalization in the XCode debug console.
In addition, Debug View in Firebase Console can help to troubleshoot Analytics Events in real
time. See the following guide https://firebase.google.com/docs/analytics/debugview#ios+. To
enable Debug Mode, use the following argument command -FIRDebugEnabled.

Web Consent Manager Integration
If you have an existing consent manager on your website that you wish to integrate with your mobile
app, you can do so by enabling mobile app consent-to-web integration. Please contact your designated
TrustArc Technical Account Manager to enable this feature.
Once the integration is enabled, follow these steps to configure it on your app:
1. Create a WKWebView implementation on your mobile app. Apply WKNavigationDelegate on the
UIViewController and implement the didCommit method for the webview.

2. Obtain Trustarcs WebScript from TrustArc.sharedInstance.getWebScript() and apply it to the

webview. 

Sample code as follows:

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

33

Swift
C/C++
class WebViewTester: UIViewController, WKNavigationDelegate {
var webView: WKWebView!
override func viewDidLoad() {
super.viewDidLoad()
webView = WKWebView(frame: .zero)
webView.translatesAutoresizingMaskIntoConstraints = false
view.addSubview(webView)
NSLayoutConstraint.activate([
webView.topAnchor.constraint(equalTo: view.topAnchor),
webView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
webView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
webView.trailingAnchor.constraint(equalTo: view.trailingAnchor)
])
if #available(iOS 16.4, *) {
webView.isInspectable = true
}
webView.navigationDelegate = self
configureWebView()
loadURL("https://trustarc.com")
}
func loadURL(_ urlString: String) {
if let url = URL(string: urlString) {
let request = URLRequest(url: url)
webView.load(request)
}
}
private func configureWebView() {
if #available(iOS 14, *) {
let preferences = WKWebpagePreferences()
preferences.allowsContentJavaScript = true
webView.configuration.defaultWebpagePreferences = preferences
} else {
webView.configuration.preferences.javaScriptEnabled = true
webView.configuration.preferences.javaScriptCanOpenWindowsAutomatically = true
}
}
public func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!) {
let taWebScript = TrustArc.sharedInstance.getWebScript()

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

34

print("WebScript", taWebScript)
webView.evaluateJavaScript(taWebScript) { result, error in
if let error = error {
print("Script injection error:", error)
} else {
print("Script injection result:", result ?? "No result")
}
}
}
}

3. To confirm that the integration is complete, open Web Inspector in Safari and view the WebView's

cookie storage.

NOTE: The consent modal will display a combined category and tracker list from both the
domain and web domain.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

35

Migration Guides
From Local Framework to Swift Package Manager (SPM)
Follow these steps to migrate from using the local XCFramework to using Github in Swift Package
Manager as your dependency source:
NOTE: This migration process is applicable for SDK versions before the 2025.04.2 release.
1. In Xcode, go to File > Add Package Dependencies
2. Click on the + button from the bottom left of the Apple Swift Packages screen and click Add
Source Control Account.

3. Select Github, then input trustarc for username and the access token provided by your
representative from the TrustArc support team for the password, then click Sign In.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

36

4. Go back to the Apple Swift Packages screen, enter
https://github.com/trustarc/trustarc-mobile-consent.git in the search bar, and press
Enter.

5. Enter "release" as the branch name or specify a version tag like "v2025.04.02", then click "Add
Package"

6. Choose your target application and click "Add Package"

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

37

7. Click on your project, then navigate to Package Dependencies. You should now be able to see
TrustArcConsentSDK listed among your Package Dependencies.

8. To verify the authenticity of the provided SDK, please check the signature in Xcode by navigating
to Package Dependencies > ios > trustarc_consent_sdk. The signature should resemble the
example shown below.

9. Remove the local trustarc_consent_sdk.xcframework from "Frameworks, Libraries, and
Embedded Content."

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

38

10. Remove the "Remove Unused Architectures Script" from your Build Phases, as it is no longer
needed when using the Swift Package.
11. Delete the local trustarc_consent_sdk.xcframework file from your project directory.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

39

React Native
The TrustArc React Native Consent SDK simplifies privacy compliance integration in your mobile
applications. This SDK provides transparency regarding third-party technologies that collect and share
user data.
The SDK enables:
 User consent collection and management
 Streamlined consent manager implementation in React Native applications
 Opt-in and opt-out analytics tracking
 Seamless connection with TrustArc's privacy management ecosystem
This guide will walk you through implementing the TrustArc Mobile Consent SDK in your React Native
application.

Requirements
 React Native 0.60 or higher
 Minimum Android SDK 28
 iOS 12.0 or higher

Before You Begin
For more information on how to get started, refer to the instructions here.

Getting Started
To integrate the React Native SDK into your app, follow the steps outlined below.
1. Add the token to your environment variables:
None
export TRUSTARC_TOKEN=<token>

2. Create a .npmrc file in the root of your project.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

40

None
@trustarc:registry=https://npm.pkg.github.com
//npm.pkg.github.com/:_authToken=${TRUSTARC_TOKEN}

This file tells npm/yarn to use GitHub Packages for the @trustarc scope and provides authentication
using your environment token.
3. Add the dependency to your package.json.
None
"dependencies": {
"@trustarc/trustarc-react-native-consent-sdk": "latest"
}

4. For Expo Project: Configure access to the GitHub Packages Maven repository for Android by
updating the app.json or app.config.js:
For app.json:
None
{
"expo": {
"plugins": [
[
"expo-build-properties",
{
"android": {
"minSdkVersion": 28,
"extraMavenRepos": [
{
"url":
"https://maven.pkg.github.com/trustarc/trustarc-mobile-consent",
"credentials": {
"username": "trustarc",
"password": "<token>"
}
}
]
}
}
]

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

41

]
}
}

For app.config.js:
None
module.exports = {
expo: {
plugins: [
[
"expo-build-properties",
{
android: {
minSdkVersion: 28,
extraMavenRepos: [
{
url: "https://maven.pkg.github.com/trustarc/trustarc-mobile-consent",
credentials: {
username: "trustarc",
password: process.env.TRUSTARC_TOKEN
}
}
]
},
},
],
],
},
};

5. For Expo Project: Add the following configuration to your app.json or app.config.js file if you
have an iOS build.
None
{
"expo": {
"ios": {
"infoPlist": {
"NSUserTrackingUsageDescription": "This identifier will be used to deliver
personalized ads to you."

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

42

}
}
}
}

For non-Expo Project: Add the following to your Info.plist
None
<dict ...>
<key>NSUserTrackingUsageDescription</key>
<string>This identifier will be used to deliver personalized ads to you.</string>
<dict>

NOTE: This step is essential to ensure that the app can request tracking permissions on iOS.
6. Install the package:
None
npm install
# or
yarn install

7. For Expo Project: Run npx expo prebuild to generate the necessary native iOS and Android
project files for your React Native application. Optionally, run npx expo prebuild --clean start
from scratch with a clean build.
8. For non-Expo Project: If your project includes iOS, navigate to the iOS directory and install
pods:
None
cd ios && pod install && cd ..

9. Create a new component (for example, TrustArcConsentScreen.tsx) and copy the following
sample implementation into it. Then import and render this component inside your main app
screen or navigation flow.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

43

JavaScript
import React, {useEffect, useState} from 'react';
import {
View,
Text,
NativeEventEmitter,
NativeModules,
StyleSheet,
} from 'react-native';
import {
SdkMode,
TrustArcSdk,
} from '@trustarc/trustarc-react-native-consent-sdk';
export default function TrustArcScreen() {
const [isSdkInitialized, setSdkInitialized] = useState(false);
// Create new SDK instance
const trustArcSdk: TrustArcSdk = new TrustArcSdk();
// Create the event emitter to listen for native events
const eventEmitter = new NativeEventEmitter(NativeModules.TrustArcMobileSdk);
// Function to initialize and start the SDK
const loadSdk = async () => {
try {
await trustArcSdk.initialize(SdkMode.standard);
await trustArcSdk.start('mac_trustarc.com', '', '');
} catch (error) {
console.error('TrustArc SDK failed to initialize:', error);
}
};
// Initialize SDK once and listen for completion
useEffect(() => {
const sdkInitListener = eventEmitter.addListener('onSdkInitFinish', () => {
setSdkInitialized(true);
console.log('TrustArc SDK initialized successfully');
});
loadSdk(); // Only once on mount
return () => {
sdkInitListener.remove(); // Clean up listener on unmount
};
}, []);
// UI rendering

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

44

return (
<View style={styles.container}>
<Text style={styles.text}>
{isSdkInitialized

 TrustArc SDK is ready!'
 Initializing TrustArc SDK...'}

? '
: '
</Text>
</View>
);
}

// Example styling (optional)
const styles = StyleSheet.create({
container: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
text: {
fontSize: 16,
padding: 10,
},
});


US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

45

Sample Implementation / Usage
Listening and Honoring User Consents
NOTE: The TrustArc SDK returns consent values as "1" (consented) or "0" (rejected) for each vendor
domain.
In cases where a domain serves multiple purposes across different categories, a numerical suffix is
added to distinguish them:
 sample.com (first occurrence - no suffix needed)
 sample.com-0 (required - when duplicate)
 sample.com-1 (functional - when duplicate)
 sample.com-2 (advertising - when duplicate)
 sample.com-3 (custom - when duplicate)
For example, if "consents.trustarc.com" appears in both functional and advertising categories, the
second instance would be labeled "consents.trustarc.com-2" to identify its advertising purpose.
None
import { TrustArcSdk } from '@trustarc/trustarc-react-native-consent-sdk';
import { NativeEventEmitter, NativeModules } from 'react-native';
import { useEffect } from 'react';
// Set up the native event emitter
const eventEmitter = new NativeEventEmitter(NativeModules.TrustArcMobileSdk);
// In your component
const YourComponent = () => {
const trustArcSdk = new TrustArcSdk();
// .. omitted codes for brevity
useEffect(() => {
// Set up an event listener for consent changes
let consentChangeListener = eventEmitter.addListener("onConsentChanges", 
async () => {
const consentData = JSON.parse(await trustArcSdk.getStoredConsentData());
// Process consent data
const consentedDomains = [];
const nonConsentedDomains = [];
// Categorized domains by suffix

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

46

const requiredDomains = [];
// -0 suffix
const functionalDomains = []; // -1 suffix
const advertisingDomains = []; // -2 suffix
const customDomains = [];
// -3 suffix
consentData.forEach(consent => {
const domain = consent.domain;
// Extract base domain if it has a category suffix
const suffixMatch = domain.match(/(.+)-(0|1|2|3)$/);
const baseDomain = suffixMatch ? suffixMatch[1] : domain;
const suffix = suffixMatch ? suffixMatch[2] : null;
// Sort by consent status
if (consent.consent === "1") {
consentedDomains.push(baseDomain);
} else {
nonConsentedDomains.push(baseDomain);
}
// Categorize by suffix
if (suffix === "0") {
requiredDomains.push(baseDomain);
} else if (suffix === "1") {
functionalDomains.push(baseDomain);
} else if (suffix === "2") {
advertisingDomains.push(baseDomain);
} else if (suffix === "3") {
customDomains.push(baseDomain);
}
});
console.log("Consented domains:", consentedDomains);
console.log("Non-consented domains:", nonConsentedDomains);
console.log("Required domains:", requiredDomains);
console.log("Functional domains:", functionalDomains);
console.log("Advertising domains:", advertisingDomains);
console.log("Custom domains:", customDomains);
});
// Clean up listener on component unmount
return () => {
consentChangeListener.remove();
};
}, []);
};

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

47

Starting with release version 2025.07.1, a new SDK function called getConsentsByCategory() has
been introduced. This function groups tracker domains by category, making it easier for developers to
retrieve consents and ensuring that the appropriate consents are correctly applied to each category.
Furthermore, domain consent values are represented by the following:
2 - Domains listed in the Required Category bucket that are always consented since they are essential
1 - Consented domains where users have granted permission
0 - Non-consented domains where users have denied or not granted permission
JavaScript
const handleConsentChanges = async () => {
try {
// Getting consent data by category (returns JSON string)
const consentDataString = await trustArcSdk.getConsentDataByCategory();
const consentMap = JSON.parse(consentDataString);
// Objects to store consented and non-consented domains for each category
const consentedDomainsByCategory: { [key: string]: string[] } = {};
const nonConsentedDomainsByCategory: { [key: string]: string[] } = {};
// Process each category
Object.entries(consentMap).forEach(([categoryName, consent]: [string, any]) => {
// Initialize arrays for this category
consentedDomainsByCategory[categoryName] = [];
nonConsentedDomainsByCategory[categoryName] = [];
// Process domains for this category
if (consent.domains) {
consent.domains.forEach((domainEntry: any) => {
Object.entries(domainEntry).forEach(([domain, consentValue]: [string, any])
=> {
if (consentValue !== "0") {
consentedDomainsByCategory[categoryName].push(domain);
} else {
nonConsentedDomainsByCategory[categoryName].push(domain);
}
});
});
}
});
// Log the results (equivalent to Android's Log.d)
Object.entries(consentedDomainsByCategory).forEach(([category, domains]) => {
console.log(`Category '${category}' - Consented domains:`, domains);
});

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

48

Object.entries(nonConsentedDomainsByCategory).forEach(([category, domains]) => {
console.log(`Category '${category}' - Non-consented domains:`, domains);
});
// Return the processed data if needed elsewhere
return {
consentedDomainsByCategory,
nonConsentedDomainsByCategory
};
} catch (error) {
console.error('Error processing consent data by category:', error);
return null;
}
};

Google Consent Mode
Google Consent Mode allows websites to adjust Google tags based on user consent status. The TrustArc
SDK provides the Consent UI and supports these consent options:
 ads_storage: Enables advertising cookies
 analytics_storage: Enables analytics cookies
 ad_personalization: Controls data use for ad personalization
 ad_user_data: Controls personal data sharing with Google services
Prerequisite: Contact your TrustArc Technical Account Manager to ensure consent mode tags are
properly mapped.
To listen to Google consent changes in your React Native application, you can use the provided
onGoogleConsentChanges method to monitor and respond to any updates in Google consent status.
None
import { TrustArcSdk } from '@trustarc/trustarc-react-native-consent-sdk';
import { NativeEventEmitter, NativeModules } from 'react-native';
import { useEffect } from 'react';
// Set up the native event emitter
const eventEmitter = new NativeEventEmitter(NativeModules.TrustArcMobileSdk);

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

49

// In your component
const YourComponent = () => {
const trustArcSdk = new TrustArcSdk();
// .. omitted codes for brevity
useEffect(() => {
// Set up an event listener for consent changes
let googleConsentChangeListener = eventEmitter
.addListener("onGoogleConsentChanges", async () => {

const googleConsentData =
JSON.parse(await trustArcSdk.getGoogleConsents());
// Add consent processing here

console.log(`Google consents: ${googleConsentData}`)
});
// Clean up listener on component unmount
return () => {
googleConsentChangeListener.remove();
};
}, []);
};

Web Consent Manager Integration
If you have an existing consent manager on your website and wish to integrate it with your mobile app,
you can do so by enabling mobile app consent-to-web integration. Please contact your designated
TrustArc Technical Account Manager to enable this feature.
Once the integration is enabled, you can call getWebScript to get the script to add the stored consents to
your React WebView component.
None
import { useEffect, useState } from "react";
import { StyleSheet, View } from "react-native";
import WebView from "react-native-webview";
import { TrustArcSdk } from "@trustarc/trustarc-react-native-consent-sdk";
function WebTester({ route }: { route: any }) {
const [webScript, setWebScript] = useState<string>("");
const trustArcSdk = new TrustArcSdk();

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

50

// .. omitted code for brevity
useEffect(() => {
const loadWebScript = async () => {
try {
const script = await trustArcSdk.getWebScript();
setWebScript(script);
} catch (error) {
console.error("Failed to get web script:", error);
}
};
loadWebScript();
}, []);
return (
<View style={styles.container}>
<WebView
originWhitelist={['*']}
style={styles.webview}
injectedJavaScriptBeforeContentLoaded={webScript}
webviewDebuggingEnabled={true}
source={{
uri: `https://notice-demo.vercel.app`,
}}
/>
</View>
);
}
const styles = StyleSheet.create({
container: {
flex: 1,
},
webview: {
flex: 1,
}
});
export default WebTester;

NOTE: Mobile Consent UI will display a combined category and tracker list from both the domain and
web domain.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

51

Migration Guides
From Local Library to GitHub Packages
Follow these steps to migrate from using the local React Native library wrapper to using GitHub Packages
as your dependency source:
NOTE: This migration process is applicable for versions 2025.04.2 and later.
1. Add the token to your environment variables.
None
export TRUSTARC_TOKEN=<token>

2. Create a .npmrc file in the root of your project.
None
@trustarc:registry=https://npm.pkg.github.com
//npm.pkg.github.com/:_authToken=${TRUSTARC_TOKEN}

This file tells npm/yarn to use GitHub Packages for the @trustarc scope and provides authentication
using your environment token.
3. Update package.json.
None
"dependencies": {
- "@trustarc-react-native/trustarc-consent-sdk":
"file:./react-native-trustarc-consent-sdk"
+ "@trustarc/trustarc-react-native-consent-sdk": "latest"
}

4. Modify metro.config.js to remove the local library references.
None
const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

52

- // Add this line to point dependency to react-native-trustarc-consent-sdk folder
- const path = require('path');
const root = path.resolve(__dirname, '.');
- const projectRoot = __dirname;
- const monorepoPackages = {
- '@trustarc-react-native/trustarc-consent-sdk': path.resolve(projectRoot,
'./react-native-trustarc-consent-sdk'),
- };

/**
* Metro configuration
* https://reactnative.dev/docs/metro
*
* @type {import('metro-config').MetroConfig}
*/
const config = {
watchFolders: [
root,
...Object.values(monorepoPackages)
],

// We need to make sure that only one version is loaded for peerDependencies
// So we block them at the root, and alias them to the versions in example's
node_modules
resolver: {
extraNodeModules: monorepoPackages
},
transformer: {
getTransformOptions: async () => ({
transform: {
experimentalImportSupport: false,
inlineRequires: true,
},
}),
},
};
module.exports = mergeConfig(getDefaultConfig(__dirname), config);

5. For Expo Project: Configure access to the GitHub Packages Maven repository for Android by

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

53

updating the app.json or app.config.js:
For app.json:
None
{
"expo": {
"plugins": [
[
"expo-build-properties",
{
"android": {
"minSdkVersion": 28,
"extraMavenRepos": [
{
"url":
"https://maven.pkg.github.com/trustarc/trustarc-mobile-consent",
"credentials": {
"username": "trustarc",
"password": "${TRUSTARC_TOKEN}"
}
}
]
}
}
]
]
}
}

For app.config.js:
None
module.exports = {
expo: {
plugins: [
[
"expo-build-properties",
{
android: {
minSdkVersion: 28,
extraMavenRepos: [
{
url: "https://maven.pkg.github.com/trustarc/trustarc-mobile-consent",
credentials: {

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

54

username: "trustarc",
password: process.env.TRUSTARC_TOKEN
}
}
]
},
},
],
],
},
};

6. Install the package (Recommended to delete node_modules):
None
npm install
# or
yarn install

7. For Expo Project: Run npx expo prebuild to regenerate the necessary native iOS and Android
project files for your React Native application. Optionally, run npx expo prebuild --clean start
from scratch with a clean build.
8. For non-Expo Project: If your project includes iOS, navigate to the iOS directory and reinstall
pods:
None
cd ios && pod install && cd ..

9. Update all @trustarc-react-native/trustarc-consent-sdk to
@trustarc/trustarc-react-native-consent-sdk throughout your project to reference the new
package name:
None
- import { TrustArcSdk } from '@trustarc-react-native/trustarc-consent-sdk';
+ import { TrustArcSdk } from '@trustarc/trustarc-react-native-consent-sdk';

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

55

10. Remove the local library folder as it's no longer needed:
None
rm -rf react-native-trustarc-consent-sdk

11. You have now successfully migrated the TrustArc Mobile Consent SDK from using local package
to using NPM.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

56

Flutter
The TrustArc Consent SDK for Flutter makes it easier to integrate privacy compliance into your mobile
apps. This SDK provides transparency regarding third-party technologies that collect and share user
data.
The SDK enables:
 User consent collection and management
 Streamlined consent manager implementation in React Native applications
 Opt-in and opt-out analytics tracking
 Seamless connection with TrustArcs privacy management ecosystem
This guide will walk you through how to implement the TrustArc Mobile Consent SDK in your Flutter app.

Requirements
 Flutter 3.27.1 and later
 Minimum Android SDK 28
 iOS 12.0 or higher

Before You Begin
For more information on how to get started, refer to the instructions here.

Getting Started
To integrate the Flutter SDK into your app, follow the steps outlined below.
1. Add the token to your environment variables:
None
export TRUSTARC_TOKEN=<token>

2. Add the dependency to your pubspec.yaml:

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

57

None
dependencies:
flutter_trustarc_mobile_consent_sdk:
git:
url: https://<token>@github.com/trustarc/trustarc-mobile-consent.git
ref: release // or use a version (ie: v2025.04.2)
path: flutter

3. Install the dependencies.
None
flutter pub get

4. Import the SDK in your Dart files and initialize it according to the TrustArc documentation.
None
import 'package:flutter/material.dart';
import
'package:flutter_trustarc_mobile_consent_sdk/flutter_trustarc_mobile_consent_sdk.dart'
;
import 'package:provider/provider.dart';
import 'package:fluttertoast/fluttertoast.dart';
void main() {
runApp(MyApp());
}
class MyApp extends StatefulWidget {
MyApp({super.key});
@override
State<MyApp> createState() => _MyAppState();
}
class _MyAppState extends State<MyApp> {
final mobileSdk = FlutterTrustarcMobileConsentSdk();
bool isInitialized = false;
@override
void initState() {
super.initState();
initializeSdk();
}

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

58

Future<void> initializeSdk() async {
await mobileSdk.initialize(SdkMode.standard);
await mobileSdk.start("mulan_mobile.com", "", "");
mobileSdk.subscribe(
onSdkInitFinish: () {
showToast(message: "SDK Init Finished");
},
onConsentChanges: () {
showToast(message: "Consents has been changed");
},
onGoogleConsentChanges: () {
showToast(message: "Google Consents has been changed");
}
);
setState(() {
isInitialized = true;
});
}
void showToast({required String message}) {
Fluttertoast.showToast(
msg: message,
toastLength: Toast.LENGTH_SHORT,
gravity: ToastGravity.BOTTOM,
timeInSecForIosWeb: 1,
backgroundColor: Colors.black87,
textColor: Colors.white,
fontSize: 16.0
);
}
Future<void> openCmButton() async {
await mobileSdk.openCM("mac_trustarc.com", "");
}
@override
Widget build(BuildContext context) {
return MultiProvider(
providers: [
Provider<FlutterTrustarcMobileConsentSdk>.value(value: mobileSdk),
],
child: MaterialApp(
title: 'MAC Flutter Demo',
theme: ThemeData(

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

59

scaffoldBackgroundColor: const Color.fromRGBO(227, 241, 241, 1),
appBarTheme: const AppBarTheme(
backgroundColor: Color.fromRGBO(227, 241, 241, 1)
)
),
home: Scaffold(
appBar: AppBar(
title: const Text('TrustArc Mobile Consent SDK'),
),
body: Center(
child: ElevatedButton(
onPressed: openCmButton,
child: const Text('Open Consent Manager'),
),
),
),
),
);
}
}

Sample Implementation / Usage
Listening and Honoring User Consents
NOTE: The TrustArc SDK returns consent values as "1" (consented) or "0" (rejected) for each vendor
domain.
In cases where a domain serves multiple purposes across different categories, a numerical suffix is
added to distinguish them:
 sample.com (first occurrence - no suffix needed)
 sample.com-0 (required - when duplicate)
 sample.com-1 (functional - when duplicate)
 sample.com-2 (advertising - when duplicate)
 sample.com-3 (custom - when duplicate)
For example, if "consents.trustarc.com" appears in both functional and advertising categories, the
second instance would be labeled "consents.trustarc.com-2" to identify its advertising purpose.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

60

None
Future<void> initializeSdk() async {
await mobileSdk.initialize(SdkMode.standard);
await mobileSdk.start("mulan_mobile.com", "", "");
mobileSdk.subscribe(
onConsentChanges: () async {
// Process consent changes when they occur
processConsents();
}
);
setState(() {
isInitialized = true;
});
}
Future<void> processConsents() async {
try {
// Get and parse consent data
String consentDataStr = await mobileSdk.getStoredConsentData();
Map<String, dynamic> consentData = jsonDecode(consentDataStr);
// Initialize categories
Map<String, List<String>> categorizedDomains = {
'consented': [],
'nonConsented': [],
'required': [],
'functional': [],
'advertising': [],
'custom': []
};
// Process each domain in the consent data
consentData.forEach((domain, consent) {
// Check for category suffix (domain-0, domain-1, etc.)
RegExp suffixRegex = RegExp(r'(.+)-(0|1|2|3)$');
RegExpMatch? match = suffixRegex.firstMatch(domain);
String baseDomain = domain;
String? suffix;
if (match != null) {
baseDomain = match.group(1) ?? domain;
suffix = match.group(2);
}
// Categorize by consent status

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

61

if (consent.toString() == "1") {
categorizedDomains['consented']!.add(baseDomain);
} else {
categorizedDomains['nonConsented']!.add(baseDomain);
}
// Categorize by purpose suffix
if (suffix == "0") {
categorizedDomains['required']!.add(baseDomain);
} else if (suffix == "1") {
categorizedDomains['functional']!.add(baseDomain);
} else if (suffix == "2") {
categorizedDomains['advertising']!.add(baseDomain);
} else if (suffix == "3") {
categorizedDomains['custom']!.add(baseDomain);
}
});
// Print results to console
print("===== CONSENT CATEGORIES =====");
print(" Consented domains: ${categorizedDomains['consented']}");
print(" Non-consented domains: ${categorizedDomains['nonConsented']}");
print("Required domains: ${categorizedDomains['required']}");
print("Functional domains: ${categorizedDomains['functional']}");
print("Advertising domains: ${categorizedDomains['advertising']}");
print("Custom domains: ${categorizedDomains['custom']}");
print("=============================");
} catch (e) {
print("Error processing consents: $e");
}
}

Starting with release version 2025.07.1, a new SDK function called getConsentsByCategory() has
been introduced. This function groups tracker domains by category, making it easier for developers to
retrieve consents and ensuring that the appropriate consents are correctly applied to each category.
Furthermore, domain consent values are represented by the following:
2 - Domains listed in the Required Category bucket that are always consented since they are essential
1 - Consented domains where users have granted permission
0 - Non-consented domains where users have denied or not granted permission

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

62

C/C++
Future<Map<String, dynamic>?> handleConsentChanges() async {
try {
// Getting consent data by category (returns JSON string)
final consentDataString = await mobileSdk.getConsentDataByCategory();
final Map<String, dynamic> consentMap = jsonDecode(consentDataString);
// Maps to store consented and non-consented domains for each category
final Map<String, List<String>> consentedDomainsByCategory = {};
final Map<String, List<String>> nonConsentedDomainsByCategory = {};
// Process each category
consentMap.forEach((categoryName, consent) {
// Initialize lists for this category
consentedDomainsByCategory[categoryName] = [];
nonConsentedDomainsByCategory[categoryName] = [];
// Process domains for this category
if (consent['domains'] != null) {
final List<dynamic> domains = consent['domains'];
for (final domainEntry in domains) {
if (domainEntry is Map<String, dynamic>) {
domainEntry.forEach((domain, consentValue) {
if (consentValue != "0") {
consentedDomainsByCategory[categoryName]!.add(domain);
} else {
nonConsentedDomainsByCategory[categoryName]!.add(domain);
}
});
}
}
}
});
// Log the results (equivalent to Android's Log.d)
consentedDomainsByCategory.forEach((category, domains) {
print("Category '$category' - Consented domains: $domains");
});
nonConsentedDomainsByCategory.forEach((category, domains) {
print("Category '$category' - Non-consented domains: $domains");
});
// Return the processed data if needed elsewhere
return {
'consentedDomainsByCategory': consentedDomainsByCategory,
'nonConsentedDomainsByCategory': nonConsentedDomainsByCategory
};

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

63

} catch (error) {
print('Error processing consent data by category: $error');
return null;
}
}

Google Consent Mode
Google Consent Mode allows websites to adjust Google tags based on user consent status. The TrustArc
SDK provides the Consent UI and supports these consent options:
 ads_storage: Enables advertising cookies
 analytics_storage: Enables analytics cookies
 ad_personalization: Controls data use for ad personalization
 ad_user_data: Controls personal data sharing with Google services
Prerequisite: Contact your TrustArc Technical Account Manager to ensure consent mode tags are
properly mapped.
To listen to Google consent changes in your React Native application, you can use the provided
onGoogleConsentChanges method to monitor and respond to any updates in Google consent status.
None
Future<void> initializeSdk() async {
await mobileSdk.initialize(SdkMode.standard);
await mobileSdk.start("mulan_mobile.com", "", "");
mobileSdk.subscribe(
onGoogleConsentChanges: () {
processGoogleConsents();
}
);
setState(() {
isInitialized = true;
});
}
Future<void> processGoogleConsents() async {
String googleConsentStr = await mobileSdk.getGoogleConsents();
print(googleConsentStr);
}

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

64

Web Consent Manager Integration
If you have an existing consent manager on your website and wish to integrate it with your mobile app,
you can do so by enabling mobile app consent-to-web integration. Please contact your designated
TrustArc Technical Account Manager to enable this feature.
Once the integration is enabled, you can call getWebScript to get the script to add the stored consents to
your React WebView component.
None
import 'package:flutter/material.dart';
import 'package:webview_flutter/webview_flutter.dart';
import 'package:webview_flutter_android/webview_flutter_android.dart';
import 'package:webview_flutter_wkwebview/webview_flutter_wkwebview.dart';
class WebTestScreen extends StatefulWidget {
const WebTestScreen({super.key});
@override
WebTestScreenState createState() => WebTestScreenState();
}
class WebTestScreenState extends State<WebTestScreen> {
late final WebViewController _controller;
@override
void initState() {
super.initState();
_controller = WebViewController()
..setJavaScriptMode(JavaScriptMode.unrestricted)
..setBackgroundColor(const Color(0x00000000))
..setNavigationDelegate(
NavigationDelegate(
onProgress: (int progress) {
// Update loading bar.
},
onPageStarted: (String url) {},
onPageFinished: (String url) async {
final args = ModalRoute.of(context)?.settings.arguments
as Map<String, dynamic>?;
// Given mobileSdk.getWebScript() was passed to this web test page
await _controller.runJavaScript(args!['webScript']);
},
onWebResourceError: (WebResourceError error) {},
onNavigationRequest: (NavigationRequest request) {

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

65

return NavigationDecision.navigate;
},
),
);
// Enable debugging based on platform
if (_controller.platform is AndroidWebViewController) {
AndroidWebViewController.enableDebugging(true);
} else if (_controller.platform is WebKitWebViewController) {
final WebKitWebViewController webKitController =
_controller.platform as WebKitWebViewController;
webKitController.setInspectable(true);
}
}
@override
Widget build(BuildContext context) {
final Map<String, dynamic>? args =
ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
if (args == null) {
return const Scaffold(
body: Center(
child: Text('No arguments provided'),
),
);
}
debugPrint(
'https://notice-demo.vercel.app');
// Load URL with query parameters
_controller.loadRequest(Uri.parse(
'https://notice-demo.vercel.app'));
return Scaffold(
appBar: AppBar(title: const Text('Web Tester')),
body: WebViewWidget(controller: _controller),
);
}
}

NOTE: Mobile Consent UI will display a combined category and tracker list from both the domain and
web domain.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

66

Migration Guides
From Local Library to GitHub Repository
Follow these steps to migrate from using the local Flutter library wrapper to using GitHub Packages as
your dependency source:
NOTE: This migration process is applicable for versions 2025.04.2 and later.
1. Add the token to your environment variables:
None
export TRUSTARC_TOKEN=<token>

2. Remove the local dependency reference from your pubspec.yaml:
None
dependencies:
- flutter_trustarc_mobile_consent_sdk:
path: ./flutter_trustarc_mobile_consent_sdk
+ flutter_trustarc_mobile_consent_sdk:
+
git:
+
url: https://<token>@github.com/trustarc/trustarc-mobile-consent.git
+
ref: release // Use a version if needed, example v2025.04.2
+
path: flutter

3. Remove the local library folder as it's no longer needed:
None
rm -rf flutter_trustarc_mobile_consent_sdk

4. Clear cache and install the dependencies.
None
flutter clean
flutter pub get

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

67

IAB Transparency & Consent
Framework (TCF 2.2)
The IAB Transparency & Consent Framework (TCF 2.2) is a standardized framework designed to help
publishers, technology vendors, and advertisers comply with data protection regulations like GDPR. It
facilitates transparency and user choice, allowing individuals to manage their privacy preferences and
consent for data processing.
The SDK is compliant with the IAB Transparency & Consent Framework (TCF 2.2). By default, the SDK
initializes in standard mode. To enable IAB TCF v2.2 mode, pass the SdkMode.IabTCFv_2_2 parameter
during the SDK initialization. This is available on all the platforms we support.

Android
Kotlin
Java
class MainActivity : AppCompatActivity() {
private lateinit var trustArcSDK: TrustArc
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
trustArcSDK = TrustArc(applicationContext, sdkMode = SdkMode.IabTCFv_2_2)
trustArcSDK.start("mac_trustarc.com")
}
}

As specified by the IAB, the consent collected will be encoded and stored locally in SharedPreferences.
You may access these values with their specific Keys.
Here is an example of how applications or third-party SDKs (vendors) access the consent information
stored on the device.
NOTE: According to the Android API reference the registerOnSharedPreferenceChangeListener does
not keep strong reference to the shared preference change listener. The recommended way is to store it
as the private property to hold strong reference during the activity lifetime.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

68

Kotlin
Java
class MainActivity : AppCompatActivity() {
private lateinit var trustArcSDK: TrustArc
private val onIabConsentListener = OnSharedPreferenceChangeListener {
sharedPreferences, key ->
onIabConsentChange(sharedPreferences, key)
}
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
@Suppress("DEPRECATION")
val sharedPrefs = PreferenceManager
.getDefaultSharedPreferences(applicationContext)
sharedPrefs.registerOnSharedPreferenceChangeListener(onIabConsentListener)
trustArcSDK = TrustArc(applicationContext, sdkMode = SdkMode.IabTCFv_2_2)
trustArcSDK.start("truste.com")
}
private fun onIabConsentChange(sharedPreferences: SharedPreferences,
key: String) {
val keyTcString = "IABTCF_TCString"
sharedPreferences.takeIf { key == keyTcString }
?.getString(keyTcString, null)
?.let { tcString ->
Log.i("IABTCF_TCString", tcString)
}
}
}

Additionally, TCF string value can also be obtained by using Trustarc.getTcfString(). For more
information, refer to the API documentation section.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

69

iOS
C/C++
override func viewDidLoad() {
super.viewDidLoad()
TrustArc.sharedInstance
.setDomain("mac_trustarc.com")
.setMode(.iabTCFv_2_2)
.start(viewController: self, completion: { (shouldShowConsentUI) in
if(shouldShowConsentUI) {
// TODO: should show consent UI
} else {
// TODO: should not show consent UI
}
})
}

As specified by the IAB, the consent collected will be encoded and stored locally in UserDefaults. You
may access these values with their specific Keys.
Here is an example of how applications or third-party SDKs (vendors) access the consent information
stored on the device. There two ways to handle changes in UserDefaults:
 KVO
 UserDefaults.didChangeNotification
NOTE: According to Apples API reference, the UserDefaults.didChangeNotification notification is posted
on the thread that changes the user defaults. The notification object is the UserDefaults object. The
notification does not contain a userInfo dictionary. This notification is not posted when changes are
made outside the current process, or when ubiquitous defaults change. You can use key-value observing
to register observers for specific keys of interest in order to be notified of all updates, regardless of
whether changes are made within or outside the current process.

Swift KVO
C/C++
extension AppDelegate {
static let keyTCString = "IABTCF_TCString"
override func observeValue(forKeyPath keyPath: String?, of object: Any?, change:
[NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
if keyPath == Self.keyTCString, let iabTcString =

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

70

UserDefaults.standard.string(forKey: Self.keyTCString) {
print("IABTCF TCString: \(iabTcString)")
}
}
func addAibConsentChangeObserver() {
UserDefaults.standard.addObserver(self, forKeyPath: Self.keyTCString, options:
[.initial, .new], context: nil)
}

func removeAibConsentChangeObserver() {
UserDefaults.standard.removeObserver(self, forKeyPath: Self.keyTCString)
}
}

Swift UserDefaults.didChangeNotification
C/C++
extension AppDelegate {
static let keyTCString = "IABTCF_TCString"
@objc func observeUserDefaultsChange(notification: Notification) {
if let iabTcString = UserDefaults.standard.string(forKey: Self.keyTCString) {
print("IABTCF TCString: \(iabTcString)")
}
}
func addAibConsentChangeObserver() {
NotificationCenter.default.addObserver(self, selector:
#selector(observeUserDefaultsChange(notification:)), name:
UserDefaults.didChangeNotification, object: nil)
}
func removeAibConsentChangeObserver() {
NotificationCenter.default.removeObserver(self)
}
}

Additionally, TCF string value can also be obtained by using Trustarc.sharedInstance.getTcfString().
For more information, refer to the API documentation section.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

71

React Native
None
await trustArcSdk.initialize(SdkMode.iabTCFv_2_2);

IAB compliance requires that user consent be properly encoded and stored within the apps local
storage. The consent data follows the IAB TCF specification and is accessible through specific keys
defined in the IABTCFPreferences enum in the API reference. You can retrieve these stored consent
values using their designated keys as needed.
None
const getIabTcfConsents = async () => {
const iabConsents = await trustArcSdk.getIABTCFPreferences();
console.log('IABTCF_VendorConsents:', iabConsents.IABTCF_VendorConsents);
console.log('IABTCF_TCString:', iabConsents.IABTCF_TCString);
}

Flutter
None
await mobileSdk.initialize(SdkMode.iabTCFv_2_2)

IAB compliance requires that user consent be properly encoded and stored within the apps local
storage. The consent data follows the IAB TCF specification and is accessible through specific keys
defined in the IABTCFPreferences enum in the API reference. You can retrieve these stored consent
values using their designated keys as needed.
None
void getIabConsents() async {
try {
IABTCFPreferences iabConsents = await mobileSdk.getIABTCFPreferences();
print("IABTCF_VendorConsents: ${iabConsents.IABTCF_VendorConsents}");

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

72

print("IABTCF_TCString: ${iabConsents.IABTCF_TCString}");
} catch (e) {
print("Error getting IAB consents: $e");
}
}

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

73

App Attribution Partner (AAP) Plugins
Overview
This provides comprehensive documentation for TrustArcs App Attribution Partner Plugins (AAP). These
plugins integrate with the TrustArc Mobile Consent SDK to provide privacy-compliant attribution and
analytics tracking based on user consent preferences.

Platform Implementation Guides
Android Implementation
The Android App Attribution Partner Plugins provide seamless integration with popular attribution and
analytics SDKs while ensuring privacy compliance through the TrustArc Mobile Consent SDK.

AndroidManifest.xml Requirements
These permissions are universally common for all SDKs. Kindly refer to the App Attribution
Partner SDK guide to learn more about these requirements.
XML
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="com.google.android.gms.permission.AD_ID" />

Supported Analytics/Attribution Partners
Firebase Analytics Plugin
 Package: com.trustarc.firebase_plugin.TAFirebasePlugin
 Purpose: Privacy-compliant Firebase Analytics integration
 Consent Management: Controls analytics data collection based on functional consent
 Official Documentation: Firebase Android Setup Guide | Get Started with Analytics

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

74

Gradle Setup:
Kotlin
dependencies {
// TrustArc Firebase Plugin
implementation("com.trustarc:trustarc-firebase-plugin:VERSION")

}

// Firebase Analytics SDK
implementation(platform("com.google.firebase:firebase-bom:34.1.0"))
implementation("com.google.firebase:firebase-analytics")

Prerequisites:
1. Add your Android app to your Firebase project.
2. Download and add the google-services.json file to your app module.
3. Add the Google services plugin to your project.
AndroidManifest Setup:
No additional AndroidManifest.xml requirements - Firebase automatically handles configuration through
google-services.json.
SDK Initialization and Plugin Initialization:
Kotlin
class MainActivity : AppCompatActivity() {
private lateinit var trustArc: TrustArc
private lateinit var taFirebasePlugin: TAFirebasePlugin
private fun setupTrustArcSdk() {
// 1. Initialize TrustArc SDK first
trustArc = TrustArc(applicationContext, SdkMode.IabTCFv_2_2)
trustArc.addSdkInitializedListener {
Log.i("TrustArc", "SDK initialized successfully")
// Setup Firebase plugin after TrustArc initialization
setupFirebasePlugin()
}

}

// Start TrustArc SDK
trustArc.start("your-domain.com")

private fun setupFirebasePlugin() {
// 2. Initialize Firebase (standard Firebase setup)
FirebaseApp.initializeApp(applicationContext)
// 3. Add Google consent listener for additional consent monitoring

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

75

trustArc.addGoogleConsentListener {
Log.d("CONSENTS", "Google consent update: $this")
}
// 4. Initialize Firebase plugin with TrustArc SDK instance
taFirebasePlugin = TAFirebasePlugin(applicationContext,
TASharedInstance.getSdkInstance())
}
}

Event Logging / SDK Usage:
Kotlin
// Usage: Logging events through the plugin (consent-controlled)
private fun logFirebaseEvent() {
// Plugin automatically controls event logging based on consent state
taFirebasePlugin.logEvent("test_event") {
it.param("event_value", "demo_test")
it.param("plugin_version", "enhanced")
it.param("timestamp", System.currentTimeMillis())
}
}
// Standard Firebase Analytics events will also be controlled by the plugin
private fun logStandardFirebaseEvent() {
Firebase.analytics.logEvent(FirebaseAnalytics.Event.SELECT_CONTENT) {
param(FirebaseAnalytics.Param.ITEM_ID, "test_item")
param(FirebaseAnalytics.Param.CONTENT_TYPE, "button")
}
}

AppsFlyer Plugin
Package: com.trustarc.trustarc_appsflyer_plugin.TAAppsFlyerPlugin
- Purpose: Privacy-compliant AppsFlyer attribution tracking
- Consent Management: Controls attribution tracking based on advertising consent
- Official Documentation: AppsFlyer Android SDK | Integration Guide
-

Gradle Setup:
Kotlin
dependencies {
// TrustArc AppsFlyer Plugin
implementation("com.trustarc:trustarc-appsflyer-plugin:VERSION")
// AppsFlyer SDK

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

76

}

implementation("com.appsflyer:af-android-sdk:6.14.2")
implementation("com.android.installreferrer:installreferrer:2.2")
implementation("com.google.android.gms:play-services-appset:16.1.0")

Prerequisites:
1. Obtain your AppsFlyer Dev Key from your AppsFlyer dashboard.
2. Ensure your apps applicationId matches the app ID in AppsFlyer.
AndroidManifest Setup:
No additional AndroidManifest.xml requirements beyond universal permissions. AppsFlyer
automatically handles install referrer and other configurations.
SDK Initialization and Plugin Initialization:
Kotlin
class MainActivity : AppCompatActivity() {
private lateinit var trustArc: TrustArc
private lateinit var appsflyerPlugin: TAAppsFlyerPlugin
private fun setupTrustArcSdk() {
// 1. Initialize TrustArc SDK first
trustArc = TrustArc(applicationContext, SdkMode.IabTCFv_2_2)
trustArc.addSdkInitializedListener {
Log.i("TrustArc", "SDK initialized successfully")
// Setup AppsFlyer plugin after TrustArc initialization
setupAppsFlyerPlugin()
}

}

// Start TrustArc SDK
trustArc.start("your-domain.com")

private fun setupAppsFlyerPlugin() {
// 2. Initialize AppsFlyer SDK with your Dev Key
AppsFlyerLib.getInstance().init("YOUR_APPSFLYER_DEV_KEY", null,
applicationContext)
AppsFlyerLib.getInstance().setDebugLog(true)
// 3. Start AppsFlyer SDK (will be controlled by TrustArc plugin)
AppsFlyerLib.getInstance().start(applicationContext)
// 4. Initialize AppsFlyer plugin with TrustArc integration
appsflyerPlugin = TAAppsFlyerPlugin(applicationContext, trustArc,
AppsFlyerLib.getInstance())
}
}

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

77

Event Logging / SDK Usage:
Kotlin
// Usage: Events are automatically controlled by plugin based on consent
private fun logAppsFlyerEvent() {
// Plugin automatically manages tracking based on consent state
AppsFlyerLib.getInstance().logEvent(applicationContext,
AFInAppEventType.ADD_TO_WISH_LIST, mapOf(
"EVENT_TEST" to "DEMO_TEST",
"plugin_version" to "enhanced",
"test_timestamp" to System.currentTimeMillis().toString()
))
}
// Custom event tracking
private fun trackPurchaseEvent() {
val eventValues = HashMap<String, Any>()
eventValues[AFInAppEventParameterName.REVENUE] = 29.99
eventValues[AFInAppEventParameterName.CURRENCY] = "USD"
eventValues[AFInAppEventParameterName.CONTENT_ID] = "product_123"
// Plugin controls whether this gets tracked based on consent
AppsFlyerLib.getInstance().logEvent(applicationContext, AFInAppEventType.PURCHASE,
eventValues)
}

Airbridge Plugin
Package: com.trustarc.airbridge_plugin.TAAirBridgePlugin
- Purpose: Privacy-compliant Airbridge attribution tracking
- Consent Management: Controls tracking and consent flags based on user preferences
- Official Documentation: Airbridge Android SDK v4 | SDK Migration Guide
-

Gradle Setup:
Kotlin
repositories {
maven { url = uri("https://sdk-download.airbridge.io/maven") }
}
dependencies {
// TrustArc Airbridge Plugin
implementation("com.trustarc:trustarc-airbridge-plugin:VERSION")

}

// Airbridge SDK v4
implementation("io.airbridge:sdk-android:2.27.2")

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

78

Prerequisites:
1. Obtain your App Name and App SDK Token from the Airbridge dashboard.
2. Create an Application class for SDK initialization.
AndroidManifest Setup:
Application class registration required:
XML
<application
android:name=".YourApplication"
android:allowBackup="true"
...>
</application>

SDK Initialization and Plugin Initialization:
Kotlin
// In your Application class
class YourApplication : Application() {
override fun onCreate() {
super.onCreate()
setupAirbridge()
}
private fun setupAirbridge() {
// 1. Airbridge SDK v4 with privacy-first initialization
val option = AirbridgeOptionBuilder("YOUR_APP_NAME", "YOUR_APP_SDK_TOKEN")
.setAutoStartTrackingEnabled(false) // Privacy by design - don't start
until consent
.build()
Airbridge.initializeSDK(this, option)
Log.d("Airbridge", "SDK v4 initialized with auto-tracking disabled for consent
management")
}
}
// In your Activity
class MainActivity : AppCompatActivity() {
private lateinit var trustArc: TrustArc
private lateinit var airbridgePlugin: TAAirBridgePlugin
private fun setupTrustArcSdk() {
// 2. Initialize TrustArc SDK first
trustArc = TrustArc(applicationContext, SdkMode.IabTCFv_2_2)
trustArc.addSdkInitializedListener {
Log.i("TrustArc", "SDK initialized successfully")
// Setup Airbridge plugin after TrustArc initialization
setupAirbridgePlugin()
}

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

79

}

}

// Start TrustArc SDK
trustArc.start("your-domain.com")

private fun setupAirbridgePlugin() {
// 3. Initialize Airbridge plugin (after TrustArc SDK initialization)
airbridgePlugin = TAAirBridgePlugin(trustArc, Airbridge)
}

Event Logging / SDK Usage:
Kotlin
// Usage: Events are automatically controlled by plugin
private fun logAirbridgeEvent() {
// Plugin controls whether this gets tracked based on consent
Airbridge.trackEvent("demo_test", mapOf(
"plugin_version" to "enhanced",
"sdk_version" to "v4",
"test_timestamp" to System.currentTimeMillis().toString()
))
}
// Custom event with properties
private fun trackPurchaseEvent() {
val eventData = mapOf(
"revenue" to 29.99,
"currency" to "USD",
"product_id" to "product_123",
"category" to "electronics"
)

}

// Plugin manages tracking and consent flags based on user preferences
Airbridge.trackEvent("purchase", eventData)

// User properties
private fun setUserProperties() {
// Plugin controls user data collection based on consent
Airbridge.setUser(mapOf(
"user_id" to "user_123",
"email" to "user@example.com"
))
}

Singular Plugin
Package: com.trustarc.trustarc_singular_plugin.TASingularPlugin
- Purpose: Privacy-compliant Singular attribution tracking
- Consent Management: Controls data sharing limitations based on consent state
- Official Documentation: Singular Android SDK Basic Integration | Prerequisites
-

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

80

Gradle Setup:
Kotlin
repositories {
maven { url = uri("https://maven.singular.net/") }
}
dependencies {
// TrustArc Singular Plugin
implementation("com.trustarc:trustarc-singular-plugin:VERSION")

}

// Singular SDK
implementation("com.singular.sdk:singular_sdk:12.10.0")

Prerequisites:
1. Complete the planning and prerequisites guide.
2. Obtain your API Key and Secret from the Singular dashboard.
3. Initialize in MainActivity (not Application class).
AndroidManifest Setup:
No additional AndroidManifest.xml requirements - Singular handles configuration programmatically
during initialization.
SDK Initialization and Plugin Initialization:
Kotlin
class MainActivity : AppCompatActivity() {
private lateinit var trustArc: TrustArc
private lateinit var singularPlugin: TASingularPlugin
private fun setupTrustArcSdk() {
// 1. Initialize TrustArc SDK first
trustArc = TrustArc(applicationContext, SdkMode.IabTCFv_2_2)
trustArc.addSdkInitializedListener {
Log.i("TrustArc", "SDK initialized successfully")
// Setup Singular plugin after TrustArc initialization
setupSingularPlugin()
}

}

// Start TrustArc SDK
trustArc.start("your-domain.com")

private fun setupSingularPlugin() {
// 2. Initialize Singular SDK with required configuration
val config = SingularConfig("YOUR_API_KEY", "YOUR_SECRET_KEY")
.withCustomUserId("custom_user_id")

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

81

.withLoggingEnabled()
.withLogLevel(1)
Singular.init(applicationContext, config)

}

}

// 3. Initialize Singular plugin with TrustArc integration
singularPlugin = TASingularPlugin(trustArc, SingularInstance.getInstance())

Event Logging / SDK Usage:
Kotlin
// Usage: Plugin manages limitDataSharing() based on consent
private fun logSingularEvent() {
val eventPayload = JSONObject()
eventPayload.put("EVENT_TEST", "DEMO_TEST")
eventPayload.put("plugin_version", "enhanced")
eventPayload.put("test_timestamp", System.currentTimeMillis())

}

// Plugin automatically manages data sharing limitations
Singular.eventJSON("test_event", eventPayload)

// Custom event tracking
private fun trackPurchaseEvent() {
val purchaseEvent = JSONObject()
purchaseEvent.put("revenue", 29.99)
purchaseEvent.put("currency", "USD")
purchaseEvent.put("product_id", "product_123")
purchaseEvent.put("category", "electronics")

}

// Plugin controls data sharing based on consent state
Singular.eventJSON("purchase", purchaseEvent)

// Revenue tracking
private fun trackRevenue() {
// Plugin manages revenue tracking based on consent
Singular.revenue("USD", 29.99)
}
// Custom user ID
private fun setCustomUserId() {
// Plugin controls user identification based on consent
Singular.setCustomUserId("user_123")
}

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

82

Consent Management & Privacy Controls
Consent Categories
The plugins operate based on two main consent categories:
1. Functional Consent (Category 1): Controls analytics and basic functionality
2. Advertising Consent (Category 2): Controls advertising tracking and attribution

Plugin Behavior Based on Consent
Firebase Analytics Plugin:
Consent State
No Consent
Functional Consent
Advertising Consent

SDK Functions Controlled
setAnalyticsCollectionEnabled(f
alse)
setAnalyticsCollectionEnabled(t
rue)
setAnalyticsCollectionEnabled(t
rue) + Ad personalization signals

Behavior
All analytics collection disabled
Analytics collection enabled
Full analytics with advertising
features

AppsFlyer Plugin:
Consent State
No Consent
Functional Consent
Advertising Consent

SDK Functions Controlled

Behavior

stop(true)

All attribution tracking stopped

setCollectOaid(false),

Limited attribution without
device identifiers

setCollectAndroidID(false)
start(), setCollectOaid(true),
setCollectAndroidID(true)

Full attribution tracking enabled

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

83

Airbridge SDK Plugin:
Consent State
No Consent

Functional Consent

SDK Functions Controlled
setAutoStartTrackingEnabled(fal
se)
startTracking() with limited

identifiers
startTracking(),

Advertising Consent

setTrackAirbridgeLinkOnly(false
)

Behavior
Tracking disabled, no event
collection
Basic event tracking without
advertising IDs
Full attribution tracking with all
identifiers

Singular SDK Plugin:
Consent State
No Consent

Functional Consent

Advertising Consent

SDK Functions Controlled
limitDataSharing(true)

limitDataSharing(false) with

restricted identifiers
limitDataSharing(false), full

identifier collection

Behavior
Data sharing limited, minimal
tracking
Basic attribution without
advertising identifiers
Complete attribution tracking and
data sharing

Best Practices
1. Privacy-First Initialization
 Initialize third-party SDKs with tracking disabled by default.
 Enable tracking only after obtaining proper consent.
 Use setAutoStartTrackingEnabled(false) for privacy-compliant initialization.
2. Consent Monitoring
 Always add consent listeners to respond to user preference changes.
 Update plugin behavior immediately when the consent state changes.
 Provide clear visual feedback to users about the tracking state.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

84

3. Error Handling
 Implement proper error handling for all plugin operations.
 Log consent state changes for debugging and compliance verification.
 Handle cases where third-party SDKs may not be available.
4. Testing
 Test all consent scenarios: no consent, functional only consent, and full consent.
 Verify that tracking is properly disabled when consent is withdrawn.
 Test deep link attribution flows under different consent states.

Troubleshooting
Common Issues
1. Plugin not responding to consent changes

 Verify that the TrustArc SDK is properly initialized before setting up plugins.
 Check that consent listeners are added before starting the SDK.
2. Attribution not working

 Ensure that advertising consent is granted for attribution plugins.
 Verify that third-party SDK initialization is correct.
 Check the deep link configuration in AndroidManifest.xml.
3. Analytics events not firing

 Verify that functional consent is granted for analytics plugins.
 Check that Firebase/Analytics SDKs are properly configured.
 Ensure that the plugin initialization order is correct.
Debugging
Kotlin
// Enable debug logging for troubleshooting
AppsFlyerLib.getInstance().setDebugLog(true)
Singular.init(applicationContext, config.withLoggingEnabled().withLogLevel(1))
Log.d("TrustArc", "Consent state: ${trustArc.getConsentDataByCategory()}")

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

85

API References
Android
Core Classes
The SDK consists of three main classes:
 TrustArc - Primary interface for interacting with the SDK. Handles initialization, consent
collection, and consent status retrieval.
 TrustArcVendorConsentViewModel - ViewModel component that manages and provides access to
vendor consent data through LiveData objects.
 TASharedInstance - Singleton manager that provides global access to the TrustArc SDK instance.

TrustArc Class
Constructor
TrustArc(context: Context, sdkMode:
SdkMode = Standard, onGoogleConsent:
GoogleConsentsListener? = null)

Description
Creates a new TrustArc instance with the specified
configuration

Initialization Methods
Methods

Description

Parameters

Return

domainName: Consent

manager domain ID

language: Locale to use
start

Starts the TrustArc SDK

when showing the
consent manager modal
(Optional)

void

onConsent: Change

listener when consent
values are changed

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

86

(Optional)
onInitFinish: Callback

when SDK has done
initializing (Optional)

domainName: Consent

manager domain ID

ipAddress: IP Address of

a specific country to
override device IP
Address (Optional)

language: Locale to use

Starts the TrustArc SDK
with IP address

start

when showing the
consent manager modal
(Optional)

void

onConsent: Change

listener when consent
values are changed
(Optional)
onInitFinish: Callback

when SDK has done
initializing (Optional)

Consent Management Methods
Methods
openCM

Description
Manually opens the
consent window
Opens the consent
window with Domain ID
and IP Address override

openCM

Parameters

DEPRECATED: No longer
necessary to provide
parameters. Domain,
language, and IP address
are already handled by
the start() method.

Return
void

domainName: Consent

manager domain ID
ip: IP Address of a

specific country to
override device IP
Address (Optional)

void

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

87

domainName: Consent

Opens consent window
with specified language
openCMWithLanguag
e

DEPRECATED: No longer
necessary to provide
parameters. Domain,
language, and IP address
are already handled by
the start() method.

manager domain ID

language: Locale to use

when showing the
consent manager modal
(Optional)

void

ip: IP Address of a

specific country to
override device IP
Address (Optional)

Information Retrieval Methods
Methods
getStoredConsentD
ata

Description
Gets the list of

VendorConsent from the

Parameters

Return

None

List<VendorConsent>

None

String?

isConsentPresent

Checks if consent is
present. Returns true if
consent is present, false
otherwise.

None

Boolean

getConsentValue

Retrieves the consent
value for a specific
tracker. The trackerId
parameter is the domain
of the tracker.

trackerId: String

String

getTrustArcDevice
UUID

Retrieves the users
consent identifier.

None

String

apps local storage

Retrieves the web script
that loads stored
preferences into the web
Consent Manager.
getWebScript

NOTE: Contact your
Technical Account
Manager for assistance
with mobile-to-web
integration.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

88

App developers can use
this UUID to display the
users identifier in the app
UI for display and
reference for their
end-user.
getLastConsent

Gets the timestamp of last
None
consent data

Long

getConsentLanguag
e

Retrieves the language
code that was used
during SDK initialization

None

String?

getTcfString

Retrieves the stored TCF
(Transparency and
Consent Framework)
string that contains
encoded user consent
data.

None

String?

Retrieves the Google
Consent Mode data that
getGoogleConsents indicates user preferences None
for Google advertising
and analytics services.

String?

getBehavior

Retrieves the consent
behavior setting, which
can be either 'implied'
(modal appears only
when manually triggered)
or 'expressed' (modal
automatically displays on
app start).

None

String?

useGdprDetection

Overrides consent
behavior to expressed,
allowing consent modal
to always show upon SDK
initialization

useGdprDetection:
boolean

void

getConsentDataByC
ategory

Retrieves the stored
consent data grouped by
category

None

Map<String,
TAConsent>

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

89

TrustArcVendorConsentViewModel
Methods

Description

Parameters

Retrieves the list of
vendor consents as a
getVendorConsents LiveData object, allowing
automatic updates when
consent data changes.

Return

LiveData<List<VendorC
onsent>>

None

Manually triggers the
loadVendorConsent process to load and
None
s
refresh the current vendor
consent data.

void

TASharedInstance
Methods

Description

Parameters

Return

context: Application

context
Creates and configures
the TrustArc SDK
singleton with specified
settings

initSdk

sdkMode: SDK mode

(default: Standard)

void

onGoogleConsent:

Optional Google
consent listener
setSdkInstance

Assigns a TrustArc
implementation to the
global singleton reference

trustArc: TrustArc

instance

void

VendorConsent
Class
VendorConsent

Method

Description
Data class that represents a vendor's consent status
with associated domain

Signature

Description

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

90

domain

String

The domain identifier for the
vendor

consent

String

The consent value ("1" for granted,
"0" for denied)

IABTCFPreferences
Type definition for IAB TCF (Transparency & Consent Framework) preferences.
Field

Description

IABTCF_PurposeOneTreatment

Indicates if Purpose One has special treatment (0 = no,
1 = yes)

IABTCF_VendorConsents

Encoded string representing vendor consents
Whether advertiser consent mode is enabled

IABTCF_enableAdvertiserConsentMode

Googles latest Firebase SDK release for iOS and
Android now supports TCF. To ensure proper consent
handling and compatibility with the SDK, please set
IABTCF_enableAdvertiserConsentMode to 1 when
using TCF so Google can infer consent from the TC
string.

IABTCF_PublisherCC

Publisher's country code (e.g., "DE", "FR")

IABTCF_PublisherConsent

Encoded string representing publisher-specific
consent

IABTCF_gdprApplies

Indicates if GDPR applies (0 = no, 1 = yes)

IABTCF_SpecialFeaturesOptIns

Encoded string representing special feature opt-ins

IABTCF_VendorLegitimateInterests

Encoded string representing vendor legitimate
interests

IABTCF_PublisherLegitimateInterests

Encoded string representing publisher legitimate
interests

IABTCF_PublisherCustomPurposesConsents

Encoded string representing publisher custom
purposes consents

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

91

IABTCF_TCString

TC string containing the encoded user consent data

IABTCF_UseNonStandardTexts

Indicates if non-standard text versions are used (0 =
no, 1 = yes)

IABTCF_PolicyVersion

IAB TCF policy version number

IABTCF_PurposeConsents

Encoded string representing purpose consents

IABTCF_PurposeLegitimateInterests

Encoded string representing purpose legitimate
interests

IABTCF_CmpSdkID

CMP SDK ID

IABTCF_CmpSdkVersion

CMP SDK version

IABTCF_PublisherCustomPurposesLegitimat
eInterests

Encoded string representing publisher custom
purposes legitimate interests

iOS
The following documentation outlines the APIs available for use in the TrustArc Mobile Consent SDK for
iOS.

TrustArc Class
The TrustArc class is the main entry point for interacting with the TrustArc SDK.
Constructor

Description

TrustArc(context:sdkMode:onGoogleConsen
t:GoogleConsentsListener:)

Creates a new TrustArc instance with the specified
configuration.

Initialization Methods
Method

Signature

Description

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

92

Starts the TrustArc SDK
@objc public func
start(withCompletion
completion: @escaping (Bool)
-> Void)

start

@objc public func
start(viewController:
UIViewController, completion:
@escaping (Bool) -> Void)

start

The boolean parameter in the
completion handler indicates
whether initialization was
successful.
Starts the TrustArc SDK with a
specific view controller
The boolean parameter in the
completion handler indicates
whether initialization was
successful.

Consent Management Methods
Method

Signature

Description

openCM

@objc public func openCM(in
viewController:
UIViewController, delegate:
TAConsentViewControllerDelegat
e?)

Opens the consent manager
window in the specified view
controller

confirmRequiredTrackers

@objc public func
confirmRequiredTrackers(in
viewController:
UIViewController, delegate:
TAConsentViewControllerDelegat
e?)

Confirms required trackers
without opening the consent
manager window

Consent Data Methods
Method

Signature

Description

getStoredConsentData

@objc public func
getStoredConsentData() ->
[String: Any]
@objc public func
isConsentPresent() -> Bool

Retrieves the stored consent data
from
./Library/Preferences/<bundle_in
dentifier of app>.plist

getWebScript

@objc public func
getWebScript() -> String

Retrieves the web script that loads
stored preferences into the web
Consent Manager

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

93

NOTE: Contact your TrustArc
Technical Account Manager for
assistance with mobile-to-web
integration.
isConsentPresent

getConsentValue

@objc public func
isConsentPresent() -> Bool

@objc public func
getConsentValue(trackerId:
String) -> String

Checks if consent is present;
returns true if consent is present,
false otherwise
Retrieves the consent value for a
specific tracker
The trackerId parameter is the
domain of the tracker.
Retrieves the TrustArc device UUID

getTrustArcDeviceUUID

@objc public func
getTrustArcDeviceUUID() ->
String

App developers can use this UUID
to display the users identifier in
the app UI for display and
reference for their end-user.

getConsentLanguage

@objc public func
getConsentLanguage() -> String

Retrieves the language code that
was used during SDK initialization

getTcfString

@objc public func
getTcfString() -> String

Retrieves the stored TCF
(Transparency and Consent
Framework) string that contains
encoded user consent data.

getGoogleConsents

@objc public func
getGoogleConsents() -> String

Retrieves the Google Consent
Mode data that indicates user
preferences for Google advertising
and analytics services.

useGdprDetection

@objc public func
useGdprDetection(_
useGdprDetection: Bool) ->
TrustArc

Overrides consent behavior to
expressed, allowing consent
modal to always show upon SDK
initialization

getConsentDataByCategory

@objc public func
getConsentDataByCategory() ->
[String :
trustarc_consent_sdk.TAConsent
]

Retrieves the stored consent data
grouped by category

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

94

TADelegate Protocol
The TADelegate protocol defines methods for handling various states of the SDK initialization and asset
downloading process.
None
@objc public protocol TADelegate {
@objc func sdkIsNotInitialized()
@objc func sdkIsInitializing()
@objc func sdkIsInitialized()
@objc optional func sdkIsDownloadingAssets()
@objc optional func sdkDidFinishDownloadingAssets()
}

TAConsentViewControllerDelegate Protocol
The TAConsentViewControllerDelegate protocol defines the callback methods on consent data
changes.
None
@objc public protocol TAConsentViewControllerDelegate {
/// When the tool's web view is loading
@objc func consentViewController(_ consentViewController:
trustarc_consent_sdk.TAConsentViewController, isLoadingWebView webView: WKWebView)
/// When the tool's web view did finish loading
@objc func consentViewController(_ consentViewController:
trustarc_consent_sdk.TAConsentViewController, didFinishLoadingWebView webView:
WKWebView)
/// When the consent tool gets the consent string
@objc func consentViewController(_ consentViewController:
trustarc_consent_sdk.TAConsentViewController, didReceiveConsentData consentData:
[String : Any])
/// When the consent tool is dismissed
@objc optional func consentViewControllerDidClose(_ consentViewController:
trustarc_consent_sdk.TAConsentViewController)
}

TAGoogleConsentsDelegate Protocol
The TAGoogleConsentsDelegate protocol defines a method for updating Google consent data. This is
US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

95

fired when Google Consent Mode (GCM) integration is enabled on the domain.
None
@objc public protocol TAGoogleConsentsDelegate {
@objc func didUpdateConsentData(consentDict: [NSString : Bool])
}

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

96

TAConsentReporterDelegate Protocol
The TAConsentReporterDelegate protocol defines methods for handling consent reporting events.
None
@objc public protocol TAConsentReporterDelegate {
@objc func consentReporterWillSend(report:
trustarc_consent_sdk.TAConsentReportInfo)
@objc func consentReporterDidSend(report:
trustarc_consent_sdk.TAConsentReportInfo)
@objc func consentReporterDidFailSending(report:
trustarc_consent_sdk.TAConsentReportInfo)
}

IABTCFPreferences
Type definition for IAB TCF (Transparency & Consent Framework) preferences.
Field

Description

IABTCF_PurposeOneTreatment

Indicates if Purpose One has special treatment (0 = no,
1 = yes)

IABTCF_VendorConsents

Encoded string representing vendor consents
Whether advertiser consent mode is enabled

IABTCF_enableAdvertiserConsentMode

Googles latest Firebase SDK release for iOS and
Android now supports TCF. To ensure proper consent
handling and compatibility with the SDK, please set
IABTCF_enableAdvertiserConsentMode to 1 when
using TCF so Google can infer consent from the TC
string.

IABTCF_PublisherCC

Publisher's country code (e.g., "DE", "FR")

IABTCF_PublisherConsent

Encoded string representing publisher-specific
consent

IABTCF_gdprApplies

Indicates if GDPR applies (0 = no, 1 = yes)

IABTCF_SpecialFeaturesOptIns

Encoded string representing special feature opt-ins

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

97

IABTCF_VendorLegitimateInterests

Encoded string representing vendor legitimate
interests

IABTCF_PublisherLegitimateInterests

Encoded string representing publisher legitimate
interests

IABTCF_PublisherCustomPurposesConsents

Encoded string representing publisher custom
purposes consents

IABTCF_TCString

TC string containing the encoded user consent data

IABTCF_UseNonStandardTexts

Indicates if non-standard text versions are used (0 =
no, 1 = yes)

IABTCF_PolicyVersion

IAB TCF policy version number

IABTCF_PurposeConsents

Encoded string representing purpose consents

IABTCF_PurposeLegitimateInterests

Encoded string representing purpose legitimate
interests

IABTCF_CmpSdkID

CMP SDK ID

IABTCF_CmpSdkVersion

CMP SDK version

IABTCF_PublisherCustomPurposesLegitimat
eInterests

Encoded string representing publisher custom
purposes legitimate interests

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

98

React Native
The following documentation outlines the APIs available for use in the TrustArc Mobile Consent SDK for
React Native projects.

TrustArc Class
The TrustArc class is the main entry point for interacting with the TrustArc SDK.
Constructor

Description
Creates a new TrustArc instance.

new TrustArcSdk()

Initialization Methods
Methods

initialize

Description
Initializes the TrustArc
SDK

Parameters

Return

sdkMode: SdkMode,

default: Standard

onGoogleConsent:

Promise<void>

Function (Optional)
domainName: String
ipAddress: String

(Optional)
start

Starts the TrustArc SDK

language: String

(Optional)

Promise<void>

onConsent: Function

(Optional)

onInitFinish: Function

(Optional)

Consent Management Methods

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

99

Methods

Description
Manually opens the
consent window

Parameters

Return

None

Promise<void>

isSdkInitialized

Validates if the SDK setup
is finished. Returns true
after the start method has
been called.

None

Promise<Boolean>

onSdkInitFinish

Event listener triggered
when the SDK has
finished initializing.

None

onConsentChanges

Event listener triggered
whenever user consent
preferences are updated.

None

Event listener triggered
when Google Consent
onGoogleConsentCh Mode (GCM) consent
values change. Requires
anges
GCM to be configured
properly for correct
category mapping.

None

openCM

Information Retrieval Methods
Methods

Description

Parameters

Gets the list of
getStoredConsentD VendorConsent from local
None
ata
storage

Return
Promise<Array<VendorC
onsent>>

getWebScript

Retrieves the web script
for web integration

None

Promise<String>

isConsentPresent

Checks if consent is
present

None

Promise<Boolean>

getConsentValue

Retrieves consent value
for a specific tracker

trackerId: String

Promise<String>

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

100

getTrustArcDevice
UUID

Retrieves the users
consent identifier

getLastConsent

Gets the timestamp of last
None
consent data

Promise<Number>

getConsentLanguag
e

Retrieves the language
code used during SDK
initialization

None

Promise<String>

getTcfString

Retrieves the TCF string
(IAB mode only)

None

Promise<String>

getGoogleConsents

Retrieves Google Consent
Mode data

None

Promise<Object>

getBehavior

Retrieves the consent
behavior setting

None

Promise<String>

useGdprDetection

Overrides consent
behavior to expressed,
allowing consent modal
to always show upon SDK
initialization

useGdprDetection:
boolean

Promise<void>

getConsentDataByC
ategory

Retrieves the stored
consent data grouped by
category

None

Promise<String>

None

Promise<String>

VendorConsent Object
Property

Type

Description

domain

String

The domain identifier for the
vendor

consent

String

The consent value ("1" for granted,
"0" for denied)

SdkMode Enum
Property

Type

Description

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

101

standard

String

Standard consent collection mode

iabTCFv_2_2

String

IAB TCF v2.2 compliant mode

IABTCFPreferences
Type definition for IAB TCF (Transparency & Consent Framework) preferences.
Field

Description

IABTCF_PurposeOneTreatment

Indicates if Purpose One has special treatment (0 = no,
1 = yes)

IABTCF_VendorConsents

Encoded string representing vendor consents
Whether advertiser consent mode is enabled

IABTCF_enableAdvertiserConsentMode

Googles latest Firebase SDK release for iOS and
Android now supports TCF. To ensure proper consent
handling and compatibility with the SDK, please set
IABTCF_enableAdvertiserConsentMode to 1 when
using TCF so Google can infer consent from the TC
string.

IABTCF_PublisherCC

Publisher's country code (e.g., "DE", "FR")

IABTCF_PublisherConsent

Encoded string representing publisher-specific
consent

IABTCF_gdprApplies

Indicates if GDPR applies (0 = no, 1 = yes)

IABTCF_SpecialFeaturesOptIns

Encoded string representing special feature opt-ins

IABTCF_VendorLegitimateInterests

Encoded string representing vendor legitimate
interests

IABTCF_PublisherLegitimateInterests

Encoded string representing publisher legitimate
interests

IABTCF_PublisherCustomPurposesConsents

Encoded string representing publisher custom
purposes consents

IABTCF_TCString

TC string containing the encoded user consent data

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

102

IABTCF_UseNonStandardTexts

Indicates if non-standard text versions are used (0 =
no, 1 = yes)

IABTCF_PolicyVersion

IAB TCF policy version number

IABTCF_PurposeConsents

Encoded string representing purpose consents

IABTCF_PurposeLegitimateInterests

Encoded string representing purpose legitimate
interests

IABTCF_CmpSdkID

CMP SDK ID

IABTCF_CmpSdkVersion

CMP SDK version

IABTCF_PublisherCustomPurposesLegitimat
eInterests

Encoded string representing publisher custom
purposes legitimate interests

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

103

Flutter
The following documentation outlines the APIs available for use in the TrustArc Mobile Consent SDK for
Flutter.

FlutterTrustarcMobileConsentSdk Class
The FlutterTrustarcMobileConsentSdk class is the main entry point for interacting with the TrustArc SDK.

Constructor
Constructor
FlutterTrustarcMobileConsentSdk()

Description
Provides methods for interacting with the TrustArc SDK

Initialization Methods
Methods

initialize

Description
Initializes the TrustArc
SDK

Parameters

Return

sdkMode: SdkMode enum

value

onGoogleConsent:

Promise<void>

Function (Optional)
domainName: String
ipAddress: String

(Optional)
Starts the TrustArc SDK

start

language: String

(Optional)

Promise<void>

onConsent: Function

(Optional)

onInitFinish: Function

(Optional)
isSdkInitialized

Validates if the SDK setup
is finished. Returns true

None

Promise<Boolean>

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

104

after the start method has
been called.
onSdkInitFinish:

Callback function
triggered when the SDK
has finished initializing.
onConsentChanges:

Callback function
triggered whenever user
consent preferences are
updated.
Subscribe to SDK events

subscribe

onGoogleConsentChange
s: Callback function

void

triggered when Google
Consent Mode (GCM)
consent values change.
GCM must be properly
configured first to
ensure correct category
mapping.

Consent Management Methods
Methods

Description
Manually opens the
consent window

openCM

Parameters

Return

domainName: String
ipAddress: String

Promise<void>

domainName: String
openCMWithLanguag
e

Open the Consent
Manager with a specified
language

language: String

Promise<void>

ipAddress: String

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

105

Information Retrieval Methods
Methods

Description

Parameters

Return

getStoredConsentD
ata

Gets the list of
VendorConsent from local None
storage

Promise<Array<VendorC
onsent>>

getWebScript

Retrieves the web script
for web integration

None

Promise<String>

isConsentPresent

Checks if consent is
present

None

Promise<Boolean>

getConsentValue

Retrieves consent value
for a specific tracker

trackerId: String

Promise<String>

getTrustArcDevice
UUID

Retrieves the users
consent identifier

None

Promise<String>

getLastConsent

Gets the timestamp of last None
consent data

Promise<Number>

getConsentLanguag
e

Retrieves the language
code used during SDK
initialization

None

Promise<String>

getTcfString

Retrieves the TCF string
(IAB mode only)

None

Promise<String>

getGoogleConsents

Retrieves Google Consent
Mode data

None

Promise<Object>

getBehavior

Retrieves the consent
behavior setting

None

Promise<String>

getSharedPreferen
ces

Retrieves all shared
preferences from native
storage

None

Promise<Map<String,
dynamic>>

getIABTCFPreferen
ces

Retrieves IAB TCF
preferences

None

IABTCFPreferences

useGdprDetection

Overrides consent
behavior to expressed,
allowing consent modal
to always show upon SDK
initialization

useGdprDetection:
boolean

Promise<void>

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

106

getConsentDataByC
ategory

Retrieves the stored
consent data grouped by
category

None

Promise<String>

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

107

SdkMode Enum
Defines the mode in which the SDK operates.
Property

Type

Description

standard

String

Standard consent collection mode

iabTCFv_2_2

String

IAB TCF v2.2 compliant mode

VendorConsent
Represents consent data for a specific vendor.
Property

Type

Description

domain

String

The domain identifier for the
vendor

consent

String

The consent value ("1" for granted,
"0" for denied)

IABTCFPreferences
Represents IAB Transparency & Consent Framework preferences.
Field

Description

IABTCF_PurposeOneTreatment

Indicates if Purpose One has special treatment (0 = no,
1 = yes)

IABTCF_VendorConsents

Encoded string representing vendor consents
Whether advertiser consent mode is enabled

IABTCF_enableAdvertiserConsentMode

Googles latest Firebase SDK release for iOS and
Android now supports TCF. To ensure proper consent
handling and compatibility with the SDK, please set
IABTCF_enableAdvertiserConsentMode to 1 when

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

108

using TCF so Google can infer consent from the TC
string.
IABTCF_PublisherCC

Publishers country code (e.g., "DE", "FR")

IABTCF_PublisherConsent

Encoded string representing publisher-specific
consent

IABTCF_gdprApplies

Indicates if GDPR applies (0 = no, 1 = yes)

IABTCF_SpecialFeaturesOptIns

Encoded string representing special feature opt-ins

IABTCF_VendorLegitimateInterests

Encoded string representing vendor legitimate
interests

IABTCF_PublisherLegitimateInterests

Encoded string representing publisher legitimate
interests

IABTCF_PublisherCustomPurposesConsents

Encoded string representing publisher custom
purposes consents

IABTCF_TCString

TC string containing the encoded user consent data

IABTCF_UseNonStandardTexts

Indicates if non-standard text versions are used (0 =
no, 1 = yes)

IABTCF_PolicyVersion

IAB TCF policy version number

IABTCF_PurposeConsents

Encoded string representing purpose consents

IABTCF_PurposeLegitimateInterests

Encoded string representing purpose legitimate
interests

IABTCF_CmpSdkID

CMP SDK ID

IABTCF_CmpSdkVersion

CMP SDK version

IABTCF_PublisherCustomPurposesLegitimat
eInterests

Encoded string representing publisher custom
purposes legitimate interests

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

109

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

110

Behavior and User Experience
The following details describe the behavior when the SDK is initiated on the mobile device and the user
has not provided their consent before.
Action
Application is opened by user

The SDK performs a series of
checks

Result
TrustArc SDK gets initiated by the app.

1. The IP address of the device is observed to determine if
the user is located inside or outside of a European
location.
2. The SDK will observe the language setting of the device.
3. The SDK will check whether a consentPreferences value
already exists on the users device and if it does, a check
of the timestamp will occur.
1. IF Behavior=Expressed and consentPreferences value
DOES NOT exist, the CM UI will be displayed and the user
will be prompted to consent.
2. IF Behavior=Expressed and consentPreferences value
DOES exist, the timestamp of the value will be used to
determine the next actions.

The SDK displays the following
behavior

a. IF timestamp value is  to 13 months, then the CM UI
will be displayed because the consentPreferences
value is invalid.
b. IF timestamp value is < 13 months, then the CM UI
will NOT display because the users consent is still
valid.
3. IF Behavior=Implied and consentPreferences value
DOES NOT exist, the CM UI will NOT be displayed. The
SDK will write a consentPreferences value to the
devices shared object that all trackers are opted-in and
allowed to load.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

111

4. IF Behavior=Implied and consentPreferences value
DOES exist, the CM UI will NOT be displayed.
a. IF timestamp value is  to 13 months, then the
consentPreferences value will be considered invalid
and overwritten to indicate that all trackers are
opted-in and allowed to load.
b. IF timestamp value is < 13 months, then the
consentPreferences value will be considered valid
and the app will honor it.
5. If SDK fails to recognize behavior, API will return
Behavior=Implied as default.
6. Any time it is indicated that CM UI should be loaded, the
devices language setting value will be used to determine
which UI language template to load/display to the user.
a. If there is not a match between the users device
language setting and a template, then the UI should
default to the English version.

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

112

Troubleshooting
SDK Integration Issue
Clients experiencing SDK issues when updating versions can try to reinstall their projects node
modules. If you observe issues similar to the below, please check the resolution options.
 iOS app crashing on startup due to errors related to the initialize method
 Android build failing with an error on line 51 in the TrustArc Java module
The issue is due to caching and version resolution problems when using the latest version specifier in
package.json. Gradle (Android) and CocoaPods (iOS) may not consistently fetch the most recent and
correct version of the native SDKs when latest is used.

Resolution
To resolve the issue, specify an exact version in the package.json instead of latest:
JSON
"@trustarc/trustarc-react-native-consent-sdk": "2025.07.1"

The version lock forces Gradle and CocoaPods to fetch the specific version, ensuring consistency across
builds.
To rollback to a previous version (if needed), you can specify:
JSON
"@trustarc/trustarc-react-native-consent-sdk": "2025.04.2"

Important: When updating SDK versions, we recommend to delete the node_modules folder or the
specific TrustArc package:

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

113

JSON
rm -rf node_modules/@trustarc/

For iOS, we also recommend to reinstall pods to ensure the latest SDK is properly integrated:
JSON
npx pod-install

or
JSON
cd ios && pod install

For Android, we also recommend to clean and rebuild the project to ensure the latest SDK is properly
integrated:
JSON
cd android && ./gradlew clean && ./gradlew build

This can be added after the iOS pod install instructions to provide complete guidance for both platforms.
For Expo:
The following command is recommended to ensure proper integration of the latest SDK:
JSON
npx expo prebuild --clean

US +1 888.878.7830 | EU +44 (0)203.078.6495 | FR +33 420.102.065 | DE +49 221.569.4412 | www.trustarc.com | 2025 TrustArc Inc.

114





=== Frequently Asked Questions ===

Q: How do I initialize the TrustArc SDK?
A: The initialization process varies by platform:
- iOS: Call TrustArcConsentImpl.shared.initialize() in AppDelegate
- Android: Call TrustArcConsentImpl.initialize(this) in Application class
- React Native: Call TrustArcConsentImpl.initialize() in useEffect hook
- Flutter: Call TrustArcConsentImpl.initialize() in main()

Q: How do I show the consent dialog?
A: Use TrustArcConsentImpl.openCm() on all platforms. This displays the consent management interface.

Q: How do I get consent data?
A: Use TrustArcConsentImpl.getConsentData() to retrieve current consent preferences.

Q: What platforms are supported?
A: TrustArc Mobile Consent SDK supports iOS (Swift), Android (Kotlin), React Native (TypeScript/JavaScript), and Flutter (Dart).

Q: What are the minimum requirements?
A:
- iOS: iOS 12.0+, Swift 5.0+
- Android: API 28+, Kotlin
- React Native: Expo or Bare Metal with auto-linking
- Flutter: Flutter 2.0+

